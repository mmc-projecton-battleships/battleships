C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE BATTLESHIPS
OBJECT MODULE PLACED IN battleships.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe battleships.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------//
   2          //User_Interface_Functions.c
   3          //----------------------------------------------------------------------------
   4          //  Copyright (C) 2016 BRAUDE COLLEGE  
   5          //  Electronics & Elictrical Engineering Department
   6          //  All rights reserved.
   7          //  Owner               :  Dr. Fadil Tareef
   8          //  FILE NAME   :  User_Interface_Functions.c 
   9          //  DATE         :  23 DEC 2016
  10          //  TARGET MCU   :  C8051F020
  11          //  DESCRIPTION  :  This file contains LCD and KEPAD Interface Functions Implementation.
  12          //                                      P1 is used for the control signals, P1.0 = E, P1.1 = RW, P1.2 = RS, output only
  13          //                                      P2 is used for data: P2.7 is read to get the status of the LCD (BF)
  14          //                                      P2 must be configured as bidirectional (open-drain) 
  15          //                                      and set to FF (or at least 80) before reading the status of P2.7
  16          //                                      P3 is used for KEPAD interface.
  17          //                                      P3.0-P3.3 connected to the COLUMNS of the KEPAD, input pins.
  18          //                                      P3.4-P3.7 connected to the ROWS of the KEPAD, output pins.
  19          //                                
  20          //      NOTES: This file used in the LCD.c file.
  21          //                 This file updated for Keil C compiler and C8051F020.
  22          //-----------------------------------------------------------------------------
  23          
  24          //#include "C8051F020.h"                  // Include register definition file.
  25          #include "User_Interface_def.h"
  26          #include "battleships.h"
  27          //----------------------------- related Functions --------------------------------
  28          char first = 't';
  29          void main()
  30          {
  31   1      
  32   1              if (first=='f') send_char('r');//tell the ARM to Reset.
  33   1              first='f';
  34   1              Init_Device();
  35   1              Init_LCD();
  36   1              Init_map();
  37   1              Main_loop();
  38   1      }
  39          void Main_loop()
  40          {
  41   1              while(1)
  42   1              {
  43   2                      switch(screen_num)
  44   2                      {
  45   3                              case 0:
  46   3                                      start_screen();
  47   3                                      break;
  48   3                              case 1:
  49   3                                      switch_difficulty();
  50   3                                      break;
  51   3                              case 2:
  52   3                                      counting_screen();
  53   3                                      break;
  54   3                              case 3:
  55   3                                      screen_data();                          
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 2   

  56   3                                      break;
  57   3                              case 4:
  58   3                                      screen_map_one();
  59   3                                      break;
  60   3                              case 5:
  61   3                                      screen_map_two();
  62   3                                      break;
  63   3                              case 6:
  64   3                                      screen_end(w);
  65   3                                      break;
  66   3                              default://bug - > print that there is a problem. ask the player to reset the game. "Error screen".
  67   3                                      break;
  68   3                      }
  69   2              }
  70   1      }
  71          
  72          
  73          void screen_data()
  74          {
  75   1              char key=0;
  76   1              while(1)
  77   1              {
  78   2                      get_data();
  79   2                      if(w!=0)
  80   2                      {
  81   3                      screen_num=6;
  82   3                      return;
  83   3                      }
  84   2                      print_current_status();
  85   2      
  86   2                      key=GET_KEY();
  87   2                      large_delay(130);
  88   2                      if(key==5)
  89   2                      {
  90   3                              screen_num=4;
  91   3                              return;
  92   3                      }
  93   2              }       
  94   1      }
  95          
  96          void print_current_status()
  97          {
  98   1              LCD_CLRS(); // clears the display
  99   1              LCD_BF();// wait untill the LCD is no longer busy
 100   1              LCD_CMD(0x02);// move the cursor home
 101   1              LCD_BF();// wait untill the LCD is no longer busy
 102   1              LCD_MSG("Time left: ");
 103   1              LCD_BF();// wait untill the LCD is no longer busy
 104   1              LCD_MSG(game_timer);
 105   1              LCD_BF();// wait untill the LCD is no longer busy
 106   1              LCD_GOTO(0x40);
 107   1              LCD_BF();// wait untill the LCD is no longer busy
 108   1              LCD_MSG("Misses left: ");
 109   1              LCD_BF();// wait untill the LCD is no longer busy
 110   1              LCD_DAT((miss_cnt/10)+'0');
 111   1              LCD_BF();
 112   1              LCD_DAT((miss_cnt%10)+'0');
 113   1              LCD_BF();// wait untill the LCD is no longer busy
 114   1      }
 115          
 116          void get_data()
 117          {
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 3   

 118   1              char s[3];
 119   1              short i;
 120   1              //send 'd', wait for input 4 times
 121   1              check_input_uart();
 122   1              if(recieved_note=='w'||recieved_note=='l')
 123   1              {
 124   2                      w=recieved_note;
 125   2                      screen_num=6;
 126   2                      return;
 127   2              }
 128   1              send_char('d');
 129   1              for(i=0;i<3;i++)
 130   1              {
 131   2                      wait_for_input();
 132   2                      if(recieved_note=='w'||recieved_note=='l')
 133   2                      {
 134   3                              w=recieved_note;
 135   3                              return;
 136   3                      }       
 137   2                      s[i]=recieved_note;
 138   2              }
 139   1              recieved_note=0;
 140   1              game_timer[0]=(s[0]/10) + '0';
 141   1              game_timer[1]=(s[0]%10) + '0';
 142   1              game_timer[2]=':';
 143   1              game_timer[3]=(s[1]/10) + '0';
 144   1              game_timer[4]=(s[1]%10) + '0';
 145   1              miss_cnt = s[2];
 146   1      }
 147          
 148          //check if there is avaible data.
 149          void check_input_uart()
 150          {
 151   1              if (!RI0)
 152   1                      return;
 153   1              recieved_note = SBUF0;
 154   1              RI0=0;
 155   1      }
 156          //wait for data.
 157          void wait_for_input()
 158          {
 159   1              while(!RI0);
 160   1              recieved_note = SBUF0;
 161   1              RI0=0;
 162   1      }
 163          //send data to ARM.
 164          void send_char(char c)
 165          {
 166   1              TI0 = 0;
 167   1              SBUF0=  c;
 168   1              while(!TI0);
 169   1              TI0= 0;
 170   1              //#devnote: add :check if the arm got the tarsmission ?
 171   1      }
 172          //wait for "secs" seconds.
 173          //#devnote: check with oscilator if the freq is legit
 174          void delay(int secs)
 175          {
 176   1              short j=0;
 177   1              short i=0;
 178   1              for (;j<secs;j++)
 179   1              {
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 4   

 180   2                      for (;i<28;i++)
 181   2                      {
 182   3                              TR0 = 1;        //START COUNTING
 183   3                              while(!TF0);    //DELAY
 184   3                              TF0=0;
 185   3                      }
 186   2              }
 187   1      }
 188          
 189          void Init_LCD()
 190          {
 191   1              LCD_BF(); // wait untill the LCD is no longer busy
 192   1              LCD_INIT();// initialize the LCD to 8 bit mode
 193   1              LCD_BF();// wait untill the LCD is no longer busy
 194   1              LCD_CMD(0x06); // curser moves from left to right
 195   1              LCD_BF();// wait untill the LCD is no longer busy
 196   1              LCD_CLRS(); // clears the display
 197   1              LCD_BF();// wait untill the LCD is no longer busy
 198   1              LCD_CMD(0x02);// move the cursor home
 199   1              LCD_BF();// wait untill the LCD is no longer busy
 200   1              
 201   1      }
 202          
 203          void start_screen()
 204          {
 205   1              LCD_CLRS(); // clears the display
 206   1              LCD_BF();// wait untill the LCD is no longer busy
 207   1              LCD_MSG("BattleShips!");
 208   1              LCD_BF();// wait untill the LCD is no longer busy
 209   1              delay(2);
 210   1              LCD_CLRS(); // clears the display
 211   1              LCD_BF();// wait untill the LCD is no longer busy
 212   1              screen_num=1;
 213   1      }
 214          
 215          
 216          void switch_difficulty()
 217          {
 218   1              char key;
 219   1              LCD_CLRS(); // clears the display
 220   1              LCD_CMD(0x02);// move the cursor home
 221   1              LCD_BF();// wait untill the LCD is no longer busy
 222   1              LCD_MSG("Please choose");
 223   1              LCD_BF();// wait untill the LCD is no longer busy
 224   1              LCD_GOTO(0x40);
 225   1              LCD_BF();// wait untill the LCD is no longer busy
 226   1              LCD_MSG("difficulty:");
 227   1              LCD_BF();// wait untill the LCD is no longer busy
 228   1              PRESSED_KEY();  //wait until pressing
 229   1              key = GET_KEY();        //save the key pressed
 230   1              KEY_RELEASE();          //wait until releasing
 231   1              LCD_DAT(ASCII_CONV(key));
 232   1              LCD_BF();// wait untill the LCD is no longer busy
 233   1              screen_num=2;
 234   1              set_difficulty(key+1);
 235   1              delay(2);
 236   1      }
 237          
 238          void set_difficulty(char difficulty)
 239          {
 240   1              if (difficulty>3)
 241   1              {
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 5   

 242   2                      delay(1);
 243   2                      screen_num=1;
 244   2                      LCD_CLRS(); // clears the display
 245   2                      LCD_CMD(0x02);// move the cursor home
 246   2                      LCD_BF();// wait untill the LCD is no longer busy
 247   2                      LCD_MSG("range: 1-3");
 248   2                      LCD_BF();// wait untill the LCD is no longer busy
 249   2                      delay(1);
 250   2                      return;
 251   2              }
 252   1              send_char(difficulty);//let the arm decide what difficulty parameters should be.
 253   1      }
 254          
 255          void counting_screen()
 256          {
 257   1              wait_for_input();
 258   1              recieved_note=0;
 259   1              LCD_CLRS(); // clears the display
 260   1              LCD_BF();// wait untill the LCD is no longer busy
 261   1              LCD_MSG("3");
 262   1              LCD_BF();// wait untill the LCD is no longer busy
 263   1              delay(1);
 264   1              LCD_CLRS(); // clears the display
 265   1              LCD_BF();// wait untill the LCD is no longer busy
 266   1              LCD_MSG("2");
 267   1              LCD_BF();// wait untill the LCD is no longer busy
 268   1              delay(1);
 269   1              LCD_CLRS(); // clears the display
 270   1              LCD_BF();// wait untill the LCD is no longer busy
 271   1              LCD_MSG("1");
 272   1              LCD_BF();// wait untill the LCD is no longer busy
 273   1              delay(1);
 274   1              LCD_CLRS(); // clears the display
 275   1              LCD_BF();// wait untill the LCD is no longer busy
 276   1              LCD_MSG("GO!");
 277   1              LCD_BF();// wait untill the LCD is no longer busy
 278   1              delay(1);
 279   1              LCD_CLRS(); // clears the display
 280   1              LCD_BF();// wait untill the LCD is no longer busy
 281   1              send_char('s');//indicate the ARM the game starts now.
 282   1              screen_num=3;//change to screen_data.
 283   1      }
 284          
 285          void screen_map_one()
 286          {
 287   1              char key=0; //used to read input from the user keyboard.
 288   1              LCD_BF();// wait untill the LCD is no longer busy
 289   1              LCD_CLRS(); // clears the display
 290   1              LCD_BF();// wait untill the LCD is no longer busy
 291   1              LCD_GOTO(0x00);
 292   1              LCD_BF();
 293   1              print_map(screen_num);
 294   1              //---------> move cursor to right place
 295   1              if(cursor>15)
 296   1                      LCD_GOTO(cursor + 0x30);
 297   1              else
 298   1                      LCD_GOTO(cursor);
 299   1              LCD_BF();// wait untill the LCD is no longer busy
 300   1              while(1) // kind of a main loop
 301   1              {
 302   2                      key = GET_KEY();
 303   2                      if(key!=0) 
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 6   

 304   2                      {
 305   3                              switch(key)
 306   3                              {
 307   4                              case 1://move cursor up. may chagnge the screen.
 308   4                                      if (cursor<=15)
 309   4                                      {
 310   5                                              screen_num=3;//change to screen_data.
 311   5                                              return;
 312   5                                      }
 313   4                                      cursor-=16;//go to upper line
 314   4                                      LCD_GOTO(cursor);
 315   4                                      break;
 316   4                              case 4://move cursor left.
 317   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 318   4                                              break;
 319   4                                      cursor--;
 320   4                                      LCD_BF();
 321   4                                      //------------>move left
 322   4                                      if(cursor>15)
 323   4                                              LCD_GOTO(cursor + 0x30);
 324   4                                      else
 325   4                                              LCD_GOTO(cursor);
 326   4                                      break;
 327   4                              case 5://move cursor down. may change screen.
 328   4                                      if (cursor>=16)
 329   4                                      {
 330   5                                              cursor-=16;
 331   5                                              screen_num=5;//go to bottom half of the map.
 332   5                                              return;
 333   5                                      }
 334   4                                      cursor+=16;
 335   4                                      LCD_BF();
 336   4                                      LCD_GOTO(cursor + 0x30);
 337   4                                      break;
 338   4                              case 6://move cursor right.
 339   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 340   4                                              break;
 341   4                                      cursor++;
 342   4                                      LCD_BF();
 343   4                                      //------------>move right
 344   4                                      if(cursor>15)
 345   4                                              LCD_GOTO(cursor + 0x30);
 346   4                                      else
 347   4                                              LCD_GOTO(cursor);
 348   4                                      break;
 349   4                              }
 350   3                      }
 351   2                      key=0;
 352   2                      check_input_uart();
 353   2                      if(recieved_note =='w'||recieved_note=='l')
 354   2                              {
 355   3                                      w=recieved_note;
 356   3                                      screen_num=6;
 357   3                                      return;
 358   3                              }
 359   2                      //hit
 360   2                      if(SW4 == 0)
 361   2                      {
 362   3                              if(map[cursor/16][cursor%16] =='X'||map[cursor/16][cursor%16]=='O') return;
 363   3                              send_char((char)cursor+1);//send to ARM the hit location.
 364   3                              wait_for_input();//wait for ARM to respond.
 365   3                              if(recieved_note == 'h')//if hit
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 7   

 366   3                              {
 367   4                                      recieved_note=0;
 368   4                                      map[cursor/16][cursor%16] = 'X';
 369   4                                      LCD_BF();
 370   4                                      LCD_DAT('X');
 371   4                                      LCD_BF();
 372   4                                      LCD_CMD(0x10);
 373   4                              }
 374   3                              else if(recieved_note == 'm')//if miss
 375   3                              {
 376   4                                      recieved_note=0;
 377   4                                      map[cursor/16][cursor%16] = 'O';
 378   4                                      LCD_BF();
 379   4                                      LCD_DAT('O');
 380   4                                      LCD_BF();
 381   4                                      LCD_CMD(0x10);
 382   4                              }
 383   3                              else if(recieved_note == 'p')
 384   3                              {
 385   4                                      recieved_note=0;
 386   4                                      update_fallen_ship();
 387   4                                      return;
 388   4                              }
 389   3                              else if(recieved_note =='w'||recieved_note=='l')
 390   3                              {
 391   4                                      w=recieved_note;
 392   4                                      screen_num=6;
 393   4                                      return;
 394   4                              }
 395   3                              while(SW4 == 0);//wait untill switch4 in released.
 396   3                      }
 397   2              }
 398   1      }
 399          
 400          void screen_map_two()
 401          {
 402   1              char key=0; //used to read input from the user keyboard.
 403   1              LCD_BF();// wait untill the LCD is no longer busy
 404   1              LCD_CLRS(); // clears the display
 405   1              LCD_BF();// wait untill the LCD is no longer busy
 406   1              LCD_GOTO(0x00);
 407   1              LCD_BF();
 408   1              print_map(screen_num);
 409   1              //---------> move cursor to right place
 410   1              if(cursor>15)
 411   1                      LCD_GOTO(cursor + 0x30);
 412   1              else
 413   1                      LCD_GOTO(cursor);
 414   1              LCD_BF();// wait untill the LCD is no longer busy
 415   1              while(1) // kind of a main loop
 416   1              {
 417   2                      key = GET_KEY();
 418   2                      if(key!=0) 
 419   2                      {
 420   3                              switch(key)
 421   3                              {
 422   4                              case 1://move cursor up. may chagnge the screen.
 423   4                                      if (cursor<=15)
 424   4                                      {
 425   5                                              screen_num=4;//change to screen_data.
 426   5                                              cursor+=16;
 427   5                                              return;
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 8   

 428   5                                      }
 429   4                                      cursor-=16;//go to upper line
 430   4                                      LCD_GOTO(cursor);
 431   4                                      break;
 432   4                              case 4://move cursor left.
 433   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 434   4                                              break;
 435   4                                      cursor--;
 436   4                                      LCD_BF();
 437   4                                      //------------>move left
 438   4                                      if(cursor>15)
 439   4                                              LCD_GOTO(cursor + 0x30);
 440   4                                      else
 441   4                                              LCD_GOTO(cursor);
 442   4                                      break;
 443   4                              case 5://move cursor down. may change screen.
 444   4                                      if (cursor>=16)
 445   4                                      {
 446   5                                              return;
 447   5                                      }
 448   4                                      cursor+=16;
 449   4                                      LCD_BF();
 450   4                                      LCD_GOTO(cursor + 0x30);
 451   4                                      break;
 452   4                              case 6://move cursor right.
 453   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 454   4                                              break;
 455   4                                      cursor++;
 456   4                                      LCD_BF();
 457   4                                      //------------>move right
 458   4                                      if(cursor>15)
 459   4                                              LCD_GOTO(cursor + 0x30);
 460   4                                      else
 461   4                                              LCD_GOTO(cursor);
 462   4                                      break;
 463   4                              }
 464   3                      }
 465   2                      key=0;
 466   2                      check_input_uart();
 467   2                      if(recieved_note =='w'||recieved_note=='l')
 468   2                              {
 469   3                                      w=recieved_note;
 470   3                                      screen_num=6;
 471   3                                      return;
 472   3                              }
 473   2                      //hit
 474   2                      if(SW4 == 0)
 475   2                      {
 476   3                              if(map[(cursor/16)+2][cursor%16] =='X'||map[(cursor/16)+2][cursor%16]=='O') return;
 477   3                              send_char((char)cursor+33);//send to ARM the hit location. +128 offset indicate 2' screen
 478   3                              wait_for_input();//wait for ARM to respond.
 479   3                              if(recieved_note == 'h')//if hit
 480   3                              {
 481   4                                      recieved_note=0;
 482   4                                      map[cursor/16+2][cursor%16] = 'X';
 483   4                                      LCD_BF();
 484   4                                      LCD_DAT('X');
 485   4                                      LCD_BF();
 486   4                                      LCD_CMD(0x10);
 487   4                              }
 488   3                              else if(recieved_note == 'm')//if miss
 489   3                              {
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 9   

 490   4                                      recieved_note=0;
 491   4                                      map[cursor/16+2][cursor%16] = 'O';
 492   4                                      LCD_BF();
 493   4                                      LCD_DAT('O');
 494   4                                      LCD_BF();
 495   4                                      LCD_CMD(0x10);
 496   4                              }
 497   3                              else if(recieved_note == 'p')
 498   3                              {
 499   4                                      recieved_note=0;
 500   4                                      update_fallen_ship();
 501   4                                      return;
 502   4                              }
 503   3                              else if(recieved_note =='w'||recieved_note=='l')
 504   3                              {
 505   4                                      w=recieved_note;
 506   4                                      screen_num=6;
 507   4                                      return;
 508   4                              }
 509   3                              while(SW4 == 0);
 510   3                      }
 511   2              }
 512   1      }
 513          //get 3 pos of the falles ship from the uart.
 514          void update_fallen_ship()
 515          {
 516   1              char pos[3];
 517   1              wait_for_input();
 518   1              pos[0]=recieved_note;
 519   1              wait_for_input();
 520   1              pos[1]=recieved_note;
 521   1              wait_for_input();
 522   1              pos[2]=recieved_note;
 523   1              recieved_note=0;
 524   1              map[pos[0]/16][pos[0]%16] = 95;// 95 = /
 525   1              if(pos[1]!='e')
 526   1                      map[pos[1]/16][pos[1]%16] = 95;
 527   1              if(pos[2]!='e')
 528   1                      map[pos[2]/16][pos[2]%16] = 95;
 529   1      }
 530          
 531          
 532          
 533          //fill map with blank boxes.
 534          void Init_map()
 535          {
 536   1              short i=0;
 537   1              short j=0;
 538   1              for(j=0;j<4;j++)
 539   1              {
 540   2                      for(i=0;i<16;i++)
 541   2                      {
 542   3                              map[j][i]= 45;//45 represent unchecked box = '-';
 543   3                      }
 544   2              }       
 545   1              
 546   1      }
 547          //print the map by the right screen. 
 548          //screen 2 = upper half. 
 549          //sceren 3 = bottom half.
 550          void print_map(int screen)
 551          {
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 10  

 552   1              short i;
 553   1              if (screen==4 || screen==5)
 554   1              {
 555   2                      
 556   2                              for (i=0;i<16;i++)
 557   2                              {
 558   3                                      LCD_BF();
 559   3                                      LCD_DAT(map[(0+2*(screen/5))][i]);
 560   3                                      LCD_BF();
 561   3                              }
 562   2                              LCD_GOTO(0x40);
 563   2                              for (i=0;i<16;i++)
 564   2                              {
 565   3                                      LCD_BF();
 566   3                                      LCD_DAT(map[1+2*(screen/5)][i]);
 567   3                                      LCD_BF();
 568   3                              }
 569   2              }
 570   1      }
 571          
 572          
 573          void screen_end(char win)
 574          {
 575   1              char* message;
 576   1              if (win=='w')
 577   1              {
 578   2                      message = "WINNER!";
 579   2              }
 580   1              else if(win=='l')
 581   1              {
 582   2                      message = "LOOSER!";
 583   2              }
 584   1              else
 585   1              {
 586   2                      message = "ERROR!";
 587   2              }
 588   1              LCD_CLRS(); // clears the display
 589   1              LCD_BF();// wait untill the LCD is no longer busy
 590   1              LCD_CMD(0x02);// move the cursor home
 591   1              LCD_BF();// wait untill the LCD is no longer busy
 592   1              LCD_MSG(message);
 593   1              LCD_BF();// wait untill the LCD is no longer busy
 594   1              delay(4);//wait 4 seconds.
 595   1              LCD_CLRS();
 596   1              LCD_BF();// wait untill the LCD is no longer busy
 597   1              LCD_MSG("please press");
 598   1              LCD_BF();
 599   1              LCD_GOTO(0x40);
 600   1              LCD_BF();
 601   1              LCD_MSG("reset button!.");
 602   1              LCD_BF();// wait untill the LCD is no longer busy
 603   1              while(1);
 604   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2196    ----
   CONSTANT SIZE    =    137    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     78      20
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.55   BATTLESHIPS                                                           06/27/2019 23:28:46 PAGE 11  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
