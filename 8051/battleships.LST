C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BATTLESHIPS
OBJECT MODULE PLACED IN battleships.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe battleships.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------//
   2          //User_Interface_Functions.c
   3          //----------------------------------------------------------------------------
   4          //  Copyright (C) 2016 BRAUDE COLLEGE  
   5          //  Electronics & Elictrical Engineering Department
   6          //  All rights reserved.
   7          //  Owner               :  Dr. Fadil Tareef
   8          //  FILE NAME   :  User_Interface_Functions.c 
   9          //  DATE         :  23 DEC 2016
  10          //  TARGET MCU   :  C8051F020
  11          //  DESCRIPTION  :  This file contains LCD and KEPAD Interface Functions Implementation.
  12          //                                      P1 is used for the control signals, P1.0 = E, P1.1 = RW, P1.2 = RS, output only
  13          //                                      P2 is used for data: P2.7 is read to get the status of the LCD (BF)
  14          //                                      P2 must be configured as bidirectional (open-drain) 
  15          //                                      and set to FF (or at least 80) before reading the status of P2.7
  16          //                                      P3 is used for KEPAD interface.
  17          //                                      P3.0-P3.3 connected to the COLUMNS of the KEPAD, input pins.
  18          //                                      P3.4-P3.7 connected to the ROWS of the KEPAD, output pins.
  19          //                                
  20          //      NOTES: This file used in the LCD.c file.
  21          //                 This file updated for Keil C compiler and C8051F020.
  22          //-----------------------------------------------------------------------------
  23          
  24          //#include "C8051F020.h"                  // Include register definition file.
  25          #include "User_Interface_def.h"
  26          #include "battleships.h"
  27          //----------------------------- related Functions --------------------------------
  28          
  29          void main()
  30          {
  31   1              Init_Device();
  32   1              Init_LCD();
  33   1              Init_map();
  34   1              Main_loop();
  35   1      }
  36          void Main_loop()
  37          {
  38   1              while(1)
  39   1              {
  40   2                      switch(screen_num)
  41   2                      {
  42   3                              case 0:
  43   3                                      start_screen();
  44   3                                      switch_difficulty();
  45   3                                      counting_screen();
  46   3                                      break;
  47   3                              case 1:
  48   3                                      screen_data();
  49   3                                      break;
  50   3                              case 2:
  51   3                                      screen_map_one();
  52   3                                      break;
  53   3                              case 3:
  54   3                                      screen_map_two();
  55   3                                      break;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 2   

  56   3                              default://bug - > print that there is a problem. ask the player to reset the game. "Error screen".
  57   3                                      break;
  58   3                      }
  59   2              }
  60   1      }
  61          
  62          
  63          void screen_data()
  64          {
  65   1              char key=0;
  66   1              while(1)
  67   1              {
  68   2                      //get_data();
  69   2                      print_current_status();
  70   2                      key=GET_KEY();
  71   2                      if(key==5)
  72   2                      {
  73   3                              screen_num=2;
  74   3                              return;
  75   3                      }
  76   2              }       
  77   1      }
  78          
  79          void print_current_status()
  80          {
  81   1              char miss;
  82   1              LCD_CLRS(); // clears the display
  83   1              LCD_BF();// wait untill the LCD is no longer busy
  84   1              LCD_CMD(0x02);// move the cursor home
  85   1              LCD_BF();// wait untill the LCD is no longer busy
  86   1              LCD_MSG("Time left: ");
  87   1              LCD_BF();// wait untill the LCD is no longer busy
  88   1              LCD_MSG(game_timer);
  89   1              LCD_BF();// wait untill the LCD is no longer busy
  90   1              LCD_GOTO(0x40);
  91   1              LCD_BF();// wait untill the LCD is no longer busy
  92   1              LCD_MSG("Misses left: ");
  93   1              LCD_BF();// wait untill the LCD is no longer busy
  94   1              miss=miss_cnt/10;
  95   1              LCD_DAT(miss+'0');
  96   1              LCD_BF();
  97   1              miss=miss_cnt%10;
  98   1              LCD_DAT(miss+'0');
  99   1              LCD_BF();// wait untill the LCD is no longer busy
 100   1      }
 101          
 102          void get_data()
 103          {
 104   1              char s[3];
 105   1              int i;
 106   1              //send 'd', wait for input 4 times
 107   1              send_char('d');
 108   1              for(i=0;i<3;i++)
 109   1              {
 110   2                      wait_for_input();
 111   2                      s[i]=recieved_note;
 112   2              }
 113   1              recieved_note=0;
 114   1              game_timer[0]=(s[0]/10) + '0';
 115   1              game_timer[1]=(s[0]%10) + '0';
 116   1              game_timer[2]=':';
 117   1              game_timer[3]=(s[1]/10) + '0';
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 3   

 118   1              game_timer[4]=(s[1]%10) + '0';
 119   1              miss_cnt = (s[2]/10)*10 + (s[2]%10);
 120   1      }
 121          
 122          //check if there is avaible data.
 123          void check_input_uart()
 124          {
 125   1              if (!RI0)
 126   1                      return;
 127   1              recieved_note = SBUF0;
 128   1              RI0=0;
 129   1      }
 130          //wait for data.
 131          void wait_for_input()
 132          {
 133   1              while(!RI0);
 134   1              recieved_note = SBUF0;
 135   1              RI0=0;
 136   1      }
 137          //send data to ARM.
 138          void send_char(char c)
 139          {
 140   1              TI0 = 0;
 141   1              SBUF0=  c;
 142   1              while(!TI0);
 143   1              TI0= 0;
 144   1              //#devnote: add :check if the arm got the tarsmission ?
 145   1      }
 146          //wait for "secs" seconds.
 147          //#devnote: check with oscilator if the freq is legit
 148          void delay(int secs)
 149          {
 150   1              int j=0;
 151   1              int i=0;
 152   1              for (;j<secs;j++)
 153   1              {
 154   2                      for (;i<28;i++)
 155   2                      {
 156   3                              TR0 = 1;        //START COUNTING
 157   3                              while(!TF0);    //DELAY
 158   3                      }
 159   2              }
 160   1      }
 161          
 162          void Init_LCD()
 163          {
 164   1              LCD_BF(); // wait untill the LCD is no longer busy
 165   1              LCD_INIT();// initialize the LCD to 8 bit mode
 166   1              LCD_BF();// wait untill the LCD is no longer busy
 167   1              LCD_CMD(0x06); // curser moves from left to right
 168   1              LCD_BF();// wait untill the LCD is no longer busy
 169   1              LCD_CLRS(); // clears the display
 170   1              LCD_BF();// wait untill the LCD is no longer busy
 171   1              LCD_CMD(0x02);// move the cursor home
 172   1              LCD_BF();// wait untill the LCD is no longer busy
 173   1              
 174   1      }
 175          
 176          void start_screen()
 177          {
 178   1              LCD_CLRS(); // clears the display
 179   1              LCD_BF();// wait untill the LCD is no longer busy
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 4   

 180   1              LCD_MSG("BattleShips!");
 181   1              LCD_BF();// wait untill the LCD is no longer busy
 182   1              delay(2);
 183   1              LCD_CLRS(); // clears the display
 184   1              LCD_BF();// wait untill the LCD is no longer busy
 185   1      }
 186          
 187          
 188          void switch_difficulty()
 189          {
 190   1              char key;
 191   1              LCD_CLRS(); // clears the display
 192   1              LCD_CMD(0x02);// move the cursor home
 193   1              LCD_BF();// wait untill the LCD is no longer busy
 194   1              LCD_MSG("Please choose");
 195   1              LCD_BF();// wait untill the LCD is no longer busy
 196   1              LCD_GOTO(0x40);
 197   1              LCD_BF();// wait untill the LCD is no longer busy
 198   1              LCD_MSG("difficulty:");
 199   1              LCD_BF();// wait untill the LCD is no longer busy
 200   1              PRESSED_KEY();  //wait until pressing
 201   1              key = GET_KEY();        //save the key pressed
 202   1              KEY_RELEASE();          //wait until releasing
 203   1              LCD_DAT(ASCII_CONV(key));
 204   1              LCD_BF();// wait untill the LCD is no longer busy
 205   1              set_difficulty(key+1);
 206   1              delay(2);
 207   1              //#devnote: add :check if difficulty
 208   1      }
 209          
 210          void set_difficulty(char difficulty)
 211          {
 212   1              char key;
 213   1              if (difficulty>3)
 214   1              {
 215   2                      LCD_BF();
 216   2                      LCD_MSG("input field:");
 217   2                      LCD_BF();
 218   2                      LCD_GOTO(0x40);
 219   2                      LCD_BF();
 220   2                      LCD_MSG("1-3");
 221   2                      delay(2);
 222   2                      while(difficulty>3)
 223   2                      {
 224   3                              LCD_CLRS(); // clears the display
 225   3                              LCD_CMD(0x02);// move the cursor home
 226   3                              LCD_BF();// wait untill the LCD is no longer busy
 227   3                              LCD_MSG("Please choose");
 228   3                              LCD_BF();// wait untill the LCD is no longer busy
 229   3                              LCD_GOTO(0x40);
 230   3                              LCD_BF();// wait untill the LCD is no longer busy
 231   3                              LCD_MSG("difficulty:");
 232   3                              LCD_BF();// wait untill the LCD is no longer busy
 233   3                              PRESSED_KEY();  //wait until pressing
 234   3                              difficulty = GET_KEY(); //save the key pressed
 235   3                              KEY_RELEASE();          //wait until releasing
 236   3                              LCD_DAT(ASCII_CONV(key));
 237   3                              delay(2);
 238   3                      }
 239   2                      LCD_CLRS(); // clears the display
 240   2              }
 241   1              send_char(difficulty);//let the arm decide what difficulty parameters should be.
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 5   

 242   1      }
 243          
 244          void counting_screen()
 245          {
 246   1              LCD_CLRS(); // clears the display
 247   1              LCD_BF();// wait untill the LCD is no longer busy
 248   1              LCD_MSG("3");
 249   1              LCD_BF();// wait untill the LCD is no longer busy
 250   1              delay(1);
 251   1              LCD_CLRS(); // clears the display
 252   1              LCD_BF();// wait untill the LCD is no longer busy
 253   1              LCD_MSG("2");
 254   1              LCD_BF();// wait untill the LCD is no longer busy
 255   1              delay(1);
 256   1              LCD_CLRS(); // clears the display
 257   1              LCD_BF();// wait untill the LCD is no longer busy
 258   1              LCD_MSG("1");
 259   1              LCD_BF();// wait untill the LCD is no longer busy
 260   1              delay(1);
 261   1              LCD_CLRS(); // clears the display
 262   1              LCD_BF();// wait untill the LCD is no longer busy
 263   1              LCD_MSG("GO!");
 264   1              LCD_BF();// wait untill the LCD is no longer busy
 265   1              delay(1);
 266   1              LCD_CLRS(); // clears the display
 267   1              LCD_BF();// wait untill the LCD is no longer busy
 268   1              send_char('s');//indicate the ARM the game starts now.
 269   1              screen_num=1;//change to screen_data.
 270   1      }
 271          
 272          void Reset_isr() interrupt 1
 273          {
 274   1              game_timer[0]='0';
 275   1              game_timer[1]='0';
 276   1              game_timer[3]='0';
 277   1              game_timer[4]='0';
 278   1              miss_cnt=0;
 279   1              TI0 = 0;
 280   1              send_char('r'); //sending "Reset" to ARM.
 281   1              Init_LCD();
 282   1              KEPAD_INIT();   // initialize the keypad
 283   1              screen_num=0;
 284   1              recieved_note=0;
 285   1              cursor =0;
 286   1              Init_map();
 287   1              Main_loop();//#devnote: when will the interrupt end ? there is a bug !.
 288   1      }
 289          
 290          void screen_map_one()
 291          {
 292   1              char key=0; //used to read input from the user keyboard.
 293   1              LCD_BF();// wait untill the LCD is no longer busy
 294   1              LCD_CLRS(); // clears the display
 295   1              LCD_BF();// wait untill the LCD is no longer busy
 296   1              //---------> move cursor to right place
 297   1              if(cursor>15)
 298   1                      LCD_GOTO(cursor + 0x30);
 299   1              else
 300   1                      LCD_GOTO(cursor);
 301   1              LCD_BF();// wait untill the LCD is no longer busy
 302   1              print_map(2);
 303   1              while(1) // kind of a main loop
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 6   

 304   1              {
 305   2                      key = GET_KEY();
 306   2                      if(key!=0) 
 307   2                      {
 308   3                              switch(key)
 309   3                              {
 310   4                              case 1://move cursor up. may chagnge the screen.
 311   4                                      if (cursor<=15)
 312   4                                      {
 313   5                                              screen_num=1;//change to screen_data.
 314   5                                              return;
 315   5                                      }
 316   4                                      cursor-=16;//go to upper line
 317   4                                      LCD_GOTO(cursor);
 318   4                                      break;
 319   4                              case 4://move cursor left.
 320   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 321   4                                              break;
 322   4                                      cursor--;
 323   4                                      LCD_BF();
 324   4                                      //------------>move left
 325   4                                      if(cursor>15)
 326   4                                              LCD_GOTO(cursor + 0x30);
 327   4                                      else
 328   4                                              LCD_GOTO(cursor);
 329   4                                      break;
 330   4                              case 5://move cursor down. may change screen.
 331   4                                      if (cursor>=16)
 332   4                                      {
 333   5                                              cursor-=16;
 334   5                                              screen_num=3;//go to bottom half of the map.
 335   5                                              return;
 336   5                                      }
 337   4                                      cursor+=16;
 338   4                                      LCD_BF();
 339   4                                      LCD_GOTO(cursor + 0x30);
 340   4                                      break;
 341   4                              case 6://move cursor right.
 342   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 343   4                                              break;
 344   4                                      cursor++;
 345   4                                      LCD_BF();
 346   4                                      //------------>move right
 347   4                                      if(cursor>15)
 348   4                                              LCD_GOTO(cursor + 0x30);
 349   4                                      else
 350   4                                              LCD_GOTO(cursor);
 351   4                                      break;
 352   4                              }
 353   3                      }
 354   2                      key=0;
 355   2                      //hit
 356   2                      if(SW4 == 0)
 357   2                      {
 358   3                              send_char((char)cursor);//send to ARM the hit location.
 359   3                              wait_for_input();//wait for ARM to respond.
 360   3                              if(recieved_note == 'h')//if hit
 361   3                              {
 362   4                                      recieved_note=0;
 363   4                                      map[cursor/16][cursor%16] = 'X';
 364   4                                      LCD_BF();
 365   4                                      LCD_DAT('X');
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 7   

 366   4                                      LCD_BF();
 367   4                              }
 368   3                              else if(recieved_note == 'm')//if miss
 369   3                              {
 370   4                                      recieved_note=0;
 371   4                                      map[cursor/16][cursor%16] = 'O';
 372   4                                      LCD_BF();
 373   4                                      LCD_DAT('O');
 374   4                                      LCD_BF();
 375   4                              }
 376   3                              else if(recieved_note == 'p')
 377   3                              {
 378   4                                      recieved_note=0;
 379   4                                      update_fallen_ship();
 380   4                                      return;
 381   4                              }
 382   3                      }
 383   2              }
 384   1      }
 385          
 386          void screen_map_two()
 387          {
 388   1              char key=0; //used to read input from the user keyboard.
 389   1              LCD_BF();// wait untill the LCD is no longer busy
 390   1              LCD_CLRS(); // clears the display
 391   1              LCD_BF();// wait untill the LCD is no longer busy
 392   1              //---------> move cursor to right place
 393   1              if(cursor>15)
 394   1                      LCD_GOTO(cursor + 0x30);
 395   1              else
 396   1                      LCD_GOTO(cursor);
 397   1              LCD_BF();// wait untill the LCD is no longer busy
 398   1              print_map(3);
 399   1              while(1) // kind of a main loop
 400   1              {
 401   2                      key = GET_KEY();
 402   2                      if(key!=0) 
 403   2                      {
 404   3                              switch(key)
 405   3                              {
 406   4                              case 1://move cursor up. may chagnge the screen.
 407   4                                      if (cursor<=15)
 408   4                                      {
 409   5                                              screen_num=2;//change to screen_data.
 410   5                                              return;
 411   5                                      }
 412   4                                      cursor-=16;//go to upper line
 413   4                                      LCD_GOTO(cursor);
 414   4                                      break;
 415   4                              case 4://move cursor left.
 416   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 417   4                                              break;
 418   4                                      cursor--;
 419   4                                      LCD_BF();
 420   4                                      //------------>move left
 421   4                                      if(cursor>15)
 422   4                                              LCD_GOTO(cursor + 0x30);
 423   4                                      else
 424   4                                              LCD_GOTO(cursor);
 425   4                                      break;
 426   4                              case 5://move cursor down. may change screen.
 427   4                                      if (cursor>=16)
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 8   

 428   4                                      {
 429   5                                              return;
 430   5                                      }
 431   4                                      cursor+=16;
 432   4                                      LCD_BF();
 433   4                                      LCD_GOTO(cursor + 0x30);
 434   4                                      break;
 435   4                              case 6://move cursor right.
 436   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 437   4                                              break;
 438   4                                      cursor++;
 439   4                                      LCD_BF();
 440   4                                      //------------>move right
 441   4                                      if(cursor>15)
 442   4                                              LCD_GOTO(cursor + 0x30);
 443   4                                      else
 444   4                                              LCD_GOTO(cursor);
 445   4                                      break;
 446   4                              }
 447   3                      }
 448   2                      key=0;
 449   2                      //hit
 450   2                      if(SW4 == 0)
 451   2                      {
 452   3                              send_char((char)cursor+128);//send to ARM the hit location. +128 offset indicate 2' screen
 453   3                              wait_for_input();//wait for ARM to respond.
 454   3                              if(recieved_note == 'h')//if hit
 455   3                              {
 456   4                                      recieved_note=0;
 457   4                                      map[cursor/16][cursor%16] = 'X';
 458   4                                      LCD_BF();
 459   4                                      LCD_DAT('X');
 460   4                                      LCD_BF();
 461   4                              }
 462   3                              else if(recieved_note == 'm')//if miss
 463   3                              {
 464   4                                      recieved_note=0;
 465   4                                      map[cursor/16][cursor%16] = 'O';
 466   4                                      LCD_BF();
 467   4                                      LCD_DAT('O');
 468   4                                      LCD_BF();
 469   4                              }
 470   3                              else if(recieved_note == 'p')
 471   3                              {
 472   4                                      recieved_note=0;
 473   4                                      update_fallen_ship();
 474   4                                      return;
 475   4                              }
 476   3                      }
 477   2              }
 478   1      }
 479          //get 3 pos of the falles ship from the uart.
 480          void update_fallen_ship()
 481          {
 482   1              char pos[3];
 483   1              wait_for_input();
 484   1              pos[0]=recieved_note;
 485   1              wait_for_input();
 486   1              pos[1]=recieved_note;
 487   1              wait_for_input();
 488   1              pos[2]=recieved_note;
 489   1              recieved_note=0;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 9   

 490   1              map[(pos[0]/128)+(pos[0]%128)/16][(pos[0]%128)%16] = 95;// 95 = /
 491   1              if(pos[1]!='e')
 492   1                      map[(pos[1]/128)+(pos[1]%128)/16][(pos[1]%128)%16] = 95;
 493   1              if(pos[2]!='e')
 494   1                      map[(pos[2]/128)+(pos[2]%128)/16][(pos[2]%128)%16] = 95;
 495   1      }
 496          
 497          
 498          
 499          //fill map with blank boxes.
 500          void Init_map()
 501          {
 502   1              int i=0;
 503   1              int j=0;
 504   1              for(j=0;j<4;j++)
 505   1              {
 506   2                      for(i=0;i<16;i++)
 507   2                      {
 508   3                              map[j][i]= 219;//219 represent unchecked box
 509   3                      }
 510   2              }       
 511   1              
 512   1      }
 513          //print the map by the right screen. 
 514          //screen 2 = upper half. 
 515          //sceren 3 = bottom half.
 516          void print_map(int screen)
 517          {
 518   1              int i;
 519   1              if (screen==2 || screen==3)
 520   1              {
 521   2                      
 522   2                              for (i=0;i<16;i++)
 523   2                              {
 524   3                                      LCD_BF();
 525   3                                      LCD_DAT(map[(0+2*(screen/3))][i]);
 526   3                                      LCD_BF();
 527   3                              }
 528   2                              LCD_GOTO(0x40);
 529   2                              for (i=0;i<16;i++)
 530   2                              {
 531   3                                      LCD_BF();
 532   3                                      LCD_DAT(map[1+2*(screen/3)][i]);
 533   3                                      LCD_BF();
 534   3                              }
 535   2              }
 536   1      }
 537          
 538          
 539          void end() interrupt 0
 540          {
 541   1              wait_for_input();
 542   1              screen_end(recieved_note);
 543   1      }
 544          
 545          void screen_end(char win)
 546          {
 547   1              char* message;
 548   1              if (win=='w')
 549   1              {
 550   2                      message = "WINNER!";
 551   2              }
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 20:37:09 PAGE 10  

 552   1              else if(win=='l')
 553   1              {
 554   2                      message = "LOOSER!";
 555   2              }
 556   1              else
 557   1              {
 558   2                      message = "ERROR!";
 559   2              }
 560   1              LCD_CLRS(); // clears the display
 561   1              LCD_BF();// wait untill the LCD is no longer busy
 562   1              LCD_CMD(0x02);// move the cursor home
 563   1              LCD_BF();// wait untill the LCD is no longer busy
 564   1              LCD_MSG(message);
 565   1              LCD_BF();// wait untill the LCD is no longer busy
 566   1              delay(4);//wait 4 seconds.
 567   1              LCD_CLRS();
 568   1              LCD_BF();// wait untill the LCD is no longer busy
 569   1              LCD_MSG("please press");
 570   1              LCD_BF();
 571   1              LCD_GOTO(0x40);
 572   1              LCD_BF();
 573   1              LCD_MSG("reset button!.");
 574   1              LCD_BF();// wait untill the LCD is no longer busy
 575   1              while(1);
 576   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2339    ----
   CONSTANT SIZE    =    143    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     76      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
