C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BATTLESHIPS
OBJECT MODULE PLACED IN battleships.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe battleships.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------//
   2          //User_Interface_Functions.c
   3          //----------------------------------------------------------------------------
   4          //  Copyright (C) 2016 BRAUDE COLLEGE  
   5          //  Electronics & Elictrical Engineering Department
   6          //  All rights reserved.
   7          //  Owner               :  Dr. Fadil Tareef
   8          //  FILE NAME   :  User_Interface_Functions.c 
   9          //  DATE         :  23 DEC 2016
  10          //  TARGET MCU   :  C8051F020
  11          //  DESCRIPTION  :  This file contains LCD and KEPAD Interface Functions Implementation.
  12          //                                      P1 is used for the control signals, P1.0 = E, P1.1 = RW, P1.2 = RS, output only
  13          //                                      P2 is used for data: P2.7 is read to get the status of the LCD (BF)
  14          //                                      P2 must be configured as bidirectional (open-drain) 
  15          //                                      and set to FF (or at least 80) before reading the status of P2.7
  16          //                                      P3 is used for KEPAD interface.
  17          //                                      P3.0-P3.3 connected to the COLUMNS of the KEPAD, input pins.
  18          //                                      P3.4-P3.7 connected to the ROWS of the KEPAD, output pins.
  19          //                                
  20          //      NOTES: This file used in the LCD.c file.
  21          //                 This file updated for Keil C compiler and C8051F020.
  22          //-----------------------------------------------------------------------------
  23          
  24          //#include "C8051F020.h"                  // Include register definition file.
  25          #include "User_Interface_def.h"
  26          #include "battleships.h"
  27          //----------------------------- related Functions --------------------------------
  28          
  29          void main()
  30          {
  31   1              send_char('r');//tell the ARM to Reset.
  32   1              Init_Device();
  33   1              Init_LCD();
  34   1              Init_map();
  35   1              Main_loop();
  36   1      }
  37          void Main_loop()
  38          {
  39   1              while(1)
  40   1              {
  41   2                      switch(screen_num)
  42   2                      {
  43   3                              case 0:
  44   3                                      start_screen();
  45   3                                      switch_difficulty();
  46   3                                      counting_screen();
  47   3                                      break;
  48   3                              case 1:
  49   3                                      screen_data();
  50   3                                      break;
  51   3                              case 2:
  52   3                                      screen_map_one();
  53   3                                      break;
  54   3                              case 3:
  55   3                                      screen_map_two();
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 2   

  56   3                                      break;
  57   3                              case 4:
  58   3                                      
  59   3                              default://bug - > print that there is a problem. ask the player to reset the game. "Error screen".
  60   3                                      break;
  61   3                      }
  62   2              }
  63   1      }
  64          
  65          
  66          void screen_data()
  67          {
  68   1              char key=0;
  69   1              while(1)
  70   1              {
  71   2                      get_data();
  72   2                      print_current_status();
  73   2                      key=GET_KEY();
  74   2                      large_delay(130);
  75   2                      if(key==5)
  76   2                      {
  77   3                              screen_num=2;
  78   3                              return;
  79   3                      }
  80   2              }       
  81   1      }
  82          
  83          void print_current_status()
  84          {
  85   1              char miss;
  86   1              LCD_CLRS(); // clears the display
  87   1              LCD_BF();// wait untill the LCD is no longer busy
  88   1              LCD_CMD(0x02);// move the cursor home
  89   1              LCD_BF();// wait untill the LCD is no longer busy
  90   1              LCD_MSG("Time left: ");
  91   1              LCD_BF();// wait untill the LCD is no longer busy
  92   1              LCD_MSG(game_timer);
  93   1              LCD_BF();// wait untill the LCD is no longer busy
  94   1              LCD_GOTO(0x40);
  95   1              LCD_BF();// wait untill the LCD is no longer busy
  96   1              LCD_MSG("Misses left: ");
  97   1              LCD_BF();// wait untill the LCD is no longer busy
  98   1              miss=miss_cnt/10;
  99   1              LCD_DAT(miss+'0');
 100   1              LCD_BF();
 101   1              miss=miss_cnt%10;
 102   1              LCD_DAT(miss+'0');
 103   1              LCD_BF();// wait untill the LCD is no longer busy
 104   1      }
 105          
 106          void get_data()
 107          {
 108   1              char s[3];
 109   1              short i;
 110   1              //send 'd', wait for input 4 times
 111   1              send_char('d');
 112   1              for(i=0;i<3;i++)
 113   1              {
 114   2                      wait_for_input();
 115   2                      s[i]=recieved_note;
 116   2              }
 117   1              recieved_note=0;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 3   

 118   1              game_timer[0]=(s[0]/10) + '0';
 119   1              game_timer[1]=(s[0]%10) + '0';
 120   1              game_timer[2]=':';
 121   1              game_timer[3]=(s[1]/10) + '0';
 122   1              game_timer[4]=(s[1]%10) + '0';
 123   1              miss_cnt = (s[2]/10)*10 + (s[2]%10);
 124   1      }
 125          
 126          //check if there is avaible data.
 127          void check_input_uart()
 128          {
 129   1              if (!RI0)
 130   1                      return;
 131   1              recieved_note = SBUF0;
 132   1              RI0=0;
 133   1      }
 134          //wait for data.
 135          void wait_for_input()
 136          {
 137   1              while(!RI0);
 138   1              recieved_note = SBUF0;
 139   1              RI0=0;
 140   1      }
 141          //send data to ARM.
 142          void send_char(char c)
 143          {
 144   1              TI0 = 0;
 145   1              SBUF0=  c;
 146   1              while(!TI0);
 147   1              TI0= 0;
 148   1              //#devnote: add :check if the arm got the tarsmission ?
 149   1      }
 150          //wait for "secs" seconds.
 151          //#devnote: check with oscilator if the freq is legit
 152          void delay(int secs)
 153          {
 154   1              short j=0;
 155   1              short i=0;
 156   1              for (;j<secs;j++)
 157   1              {
 158   2                      for (;i<28;i++)
 159   2                      {
 160   3                              TR0 = 1;        //START COUNTING
 161   3                              while(!TF0);    //DELAY
 162   3                      }
 163   2              }
 164   1      }
 165          
 166          void Init_LCD()
 167          {
 168   1              LCD_BF(); // wait untill the LCD is no longer busy
 169   1              LCD_INIT();// initialize the LCD to 8 bit mode
 170   1              LCD_BF();// wait untill the LCD is no longer busy
 171   1              LCD_CMD(0x06); // curser moves from left to right
 172   1              LCD_BF();// wait untill the LCD is no longer busy
 173   1              LCD_CLRS(); // clears the display
 174   1              LCD_BF();// wait untill the LCD is no longer busy
 175   1              LCD_CMD(0x02);// move the cursor home
 176   1              LCD_BF();// wait untill the LCD is no longer busy
 177   1              
 178   1      }
 179          
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 4   

 180          void start_screen()
 181          {
 182   1              LCD_CLRS(); // clears the display
 183   1              LCD_BF();// wait untill the LCD is no longer busy
 184   1              LCD_MSG("BattleShips!");
 185   1              LCD_BF();// wait untill the LCD is no longer busy
 186   1              delay(2);
 187   1              LCD_CLRS(); // clears the display
 188   1              LCD_BF();// wait untill the LCD is no longer busy
 189   1      }
 190          
 191          
 192          void switch_difficulty()
 193          {
 194   1              char key;
 195   1              LCD_CLRS(); // clears the display
 196   1              LCD_CMD(0x02);// move the cursor home
 197   1              LCD_BF();// wait untill the LCD is no longer busy
 198   1              LCD_MSG("Please choose");
 199   1              LCD_BF();// wait untill the LCD is no longer busy
 200   1              LCD_GOTO(0x40);
 201   1              LCD_BF();// wait untill the LCD is no longer busy
 202   1              LCD_MSG("difficulty:");
 203   1              LCD_BF();// wait untill the LCD is no longer busy
 204   1              PRESSED_KEY();  //wait until pressing
 205   1              key = GET_KEY();        //save the key pressed
 206   1              KEY_RELEASE();          //wait until releasing
 207   1              LCD_DAT(ASCII_CONV(key));
 208   1              LCD_BF();// wait untill the LCD is no longer busy
 209   1              set_difficulty(key+1);
 210   1              delay(2);
 211   1      }
 212          
 213          void set_difficulty(char difficulty)
 214          {
 215   1              char key;
 216   1              if (difficulty>3)
 217   1              {
 218   2                      LCD_BF();
 219   2                      LCD_MSG("input field:");
 220   2                      LCD_BF();
 221   2                      LCD_GOTO(0x40);
 222   2                      LCD_BF();
 223   2                      LCD_MSG("1-3");
 224   2                      delay(2);
 225   2                      while(difficulty>3)
 226   2                      {
 227   3                              LCD_CLRS(); // clears the display
 228   3                              LCD_CMD(0x02);// move the cursor home
 229   3                              LCD_BF();// wait untill the LCD is no longer busy
 230   3                              LCD_MSG("Please choose");
 231   3                              LCD_BF();// wait untill the LCD is no longer busy
 232   3                              LCD_GOTO(0x40);
 233   3                              LCD_BF();// wait untill the LCD is no longer busy
 234   3                              LCD_MSG("difficulty:");
 235   3                              LCD_BF();// wait untill the LCD is no longer busy
 236   3                              PRESSED_KEY();  //wait until pressing
 237   3                              difficulty = GET_KEY(); //save the key pressed
 238   3                              KEY_RELEASE();          //wait until releasing
 239   3                              LCD_DAT(ASCII_CONV(key));
 240   3                              delay(2);
 241   3                      }
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 5   

 242   2                      LCD_CLRS(); // clears the display
 243   2              }
 244   1              send_char(difficulty);//let the arm decide what difficulty parameters should be.
 245   1      }
 246          
 247          void counting_screen()
 248          {
 249   1              LCD_CLRS(); // clears the display
 250   1              LCD_BF();// wait untill the LCD is no longer busy
 251   1              LCD_MSG("3");
 252   1              LCD_BF();// wait untill the LCD is no longer busy
 253   1              delay(1);
 254   1              LCD_CLRS(); // clears the display
 255   1              LCD_BF();// wait untill the LCD is no longer busy
 256   1              LCD_MSG("2");
 257   1              LCD_BF();// wait untill the LCD is no longer busy
 258   1              delay(1);
 259   1              LCD_CLRS(); // clears the display
 260   1              LCD_BF();// wait untill the LCD is no longer busy
 261   1              LCD_MSG("1");
 262   1              LCD_BF();// wait untill the LCD is no longer busy
 263   1              delay(1);
 264   1              LCD_CLRS(); // clears the display
 265   1              LCD_BF();// wait untill the LCD is no longer busy
 266   1              LCD_MSG("GO!");
 267   1              LCD_BF();// wait untill the LCD is no longer busy
 268   1              delay(1);
 269   1              LCD_CLRS(); // clears the display
 270   1              LCD_BF();// wait untill the LCD is no longer busy
 271   1              send_char('s');//indicate the ARM the game starts now.
 272   1              screen_num=1;//change to screen_data.
 273   1      }
 274          
 275          void screen_map_one()
 276          {
 277   1              char key=0; //used to read input from the user keyboard.
 278   1              LCD_BF();// wait untill the LCD is no longer busy
 279   1              LCD_CLRS(); // clears the display
 280   1              LCD_BF();// wait untill the LCD is no longer busy
 281   1              //---------> move cursor to right place
 282   1              if(cursor>15)
 283   1                      LCD_GOTO(cursor + 0x30);
 284   1              else
 285   1                      LCD_GOTO(cursor);
 286   1              LCD_BF();// wait untill the LCD is no longer busy
 287   1              print_map(2);
 288   1              while(1) // kind of a main loop
 289   1              {
 290   2                      key = GET_KEY();
 291   2                      if(key!=0) 
 292   2                      {
 293   3                              switch(key)
 294   3                              {
 295   4                              case 1://move cursor up. may chagnge the screen.
 296   4                                      if (cursor<=15)
 297   4                                      {
 298   5                                              screen_num=1;//change to screen_data.
 299   5                                              return;
 300   5                                      }
 301   4                                      cursor-=16;//go to upper line
 302   4                                      LCD_GOTO(cursor);
 303   4                                      break;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 6   

 304   4                              case 4://move cursor left.
 305   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 306   4                                              break;
 307   4                                      cursor--;
 308   4                                      LCD_BF();
 309   4                                      //------------>move left
 310   4                                      if(cursor>15)
 311   4                                              LCD_GOTO(cursor + 0x30);
 312   4                                      else
 313   4                                              LCD_GOTO(cursor);
 314   4                                      break;
 315   4                              case 5://move cursor down. may change screen.
 316   4                                      if (cursor>=16)
 317   4                                      {
 318   5                                              cursor-=16;
 319   5                                              screen_num=3;//go to bottom half of the map.
 320   5                                              return;
 321   5                                      }
 322   4                                      cursor+=16;
 323   4                                      LCD_BF();
 324   4                                      LCD_GOTO(cursor + 0x30);
 325   4                                      break;
 326   4                              case 6://move cursor right.
 327   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 328   4                                              break;
 329   4                                      cursor++;
 330   4                                      LCD_BF();
 331   4                                      //------------>move right
 332   4                                      if(cursor>15)
 333   4                                              LCD_GOTO(cursor + 0x30);
 334   4                                      else
 335   4                                              LCD_GOTO(cursor);
 336   4                                      break;
 337   4                              }
 338   3                      }
 339   2                      key=0;
 340   2                      //hit
 341   2                      if(SW4 == 0)
 342   2                      {
 343   3                              send_char((char)cursor);//send to ARM the hit location.
 344   3                              wait_for_input();//wait for ARM to respond.
 345   3                              if(recieved_note == 'h')//if hit
 346   3                              {
 347   4                                      recieved_note=0;
 348   4                                      map[cursor/16][cursor%16] = 'X';
 349   4                                      LCD_BF();
 350   4                                      LCD_DAT('X');
 351   4                                      LCD_BF();
 352   4                              }
 353   3                              else if(recieved_note == 'm')//if miss
 354   3                              {
 355   4                                      recieved_note=0;
 356   4                                      map[cursor/16][cursor%16] = 'O';
 357   4                                      LCD_BF();
 358   4                                      LCD_DAT('O');
 359   4                                      LCD_BF();
 360   4                              }
 361   3                              else if(recieved_note == 'p')
 362   3                              {
 363   4                                      recieved_note=0;
 364   4                                      update_fallen_ship();
 365   4                                      return;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 7   

 366   4                              }
 367   3                      }
 368   2              }
 369   1      }
 370          
 371          void screen_map_two()
 372          {
 373   1              char key=0; //used to read input from the user keyboard.
 374   1              LCD_BF();// wait untill the LCD is no longer busy
 375   1              LCD_CLRS(); // clears the display
 376   1              LCD_BF();// wait untill the LCD is no longer busy
 377   1              //---------> move cursor to right place
 378   1              if(cursor>15)
 379   1                      LCD_GOTO(cursor + 0x30);
 380   1              else
 381   1                      LCD_GOTO(cursor);
 382   1              LCD_BF();// wait untill the LCD is no longer busy
 383   1              print_map(3);
 384   1              while(1) // kind of a main loop
 385   1              {
 386   2                      key = GET_KEY();
 387   2                      if(key!=0) 
 388   2                      {
 389   3                              switch(key)
 390   3                              {
 391   4                              case 1://move cursor up. may chagnge the screen.
 392   4                                      if (cursor<=15)
 393   4                                      {
 394   5                                              screen_num=2;//change to screen_data.
 395   5                                              return;
 396   5                                      }
 397   4                                      cursor-=16;//go to upper line
 398   4                                      LCD_GOTO(cursor);
 399   4                                      break;
 400   4                              case 4://move cursor left.
 401   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 402   4                                              break;
 403   4                                      cursor--;
 404   4                                      LCD_BF();
 405   4                                      //------------>move left
 406   4                                      if(cursor>15)
 407   4                                              LCD_GOTO(cursor + 0x30);
 408   4                                      else
 409   4                                              LCD_GOTO(cursor);
 410   4                                      break;
 411   4                              case 5://move cursor down. may change screen.
 412   4                                      if (cursor>=16)
 413   4                                      {
 414   5                                              return;
 415   5                                      }
 416   4                                      cursor+=16;
 417   4                                      LCD_BF();
 418   4                                      LCD_GOTO(cursor + 0x30);
 419   4                                      break;
 420   4                              case 6://move cursor right.
 421   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 422   4                                              break;
 423   4                                      cursor++;
 424   4                                      LCD_BF();
 425   4                                      //------------>move right
 426   4                                      if(cursor>15)
 427   4                                              LCD_GOTO(cursor + 0x30);
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 8   

 428   4                                      else
 429   4                                              LCD_GOTO(cursor);
 430   4                                      break;
 431   4                              }
 432   3                      }
 433   2                      key=0;
 434   2                      //hit
 435   2                      if(SW4 == 0)
 436   2                      {
 437   3                              send_char((char)cursor+128);//send to ARM the hit location. +128 offset indicate 2' screen
 438   3                              wait_for_input();//wait for ARM to respond.
 439   3                              if(recieved_note == 'h')//if hit
 440   3                              {
 441   4                                      recieved_note=0;
 442   4                                      map[cursor/16][cursor%16] = 'X';
 443   4                                      LCD_BF();
 444   4                                      LCD_DAT('X');
 445   4                                      LCD_BF();
 446   4                              }
 447   3                              else if(recieved_note == 'm')//if miss
 448   3                              {
 449   4                                      recieved_note=0;
 450   4                                      map[cursor/16][cursor%16] = 'O';
 451   4                                      LCD_BF();
 452   4                                      LCD_DAT('O');
 453   4                                      LCD_BF();
 454   4                              }
 455   3                              else if(recieved_note == 'p')
 456   3                              {
 457   4                                      recieved_note=0;
 458   4                                      update_fallen_ship();
 459   4                                      return;
 460   4                              }
 461   3                      }
 462   2              }
 463   1      }
 464          //get 3 pos of the falles ship from the uart.
 465          void update_fallen_ship()
 466          {
 467   1              char pos[3];
 468   1              wait_for_input();
 469   1              pos[0]=recieved_note;
 470   1              wait_for_input();
 471   1              pos[1]=recieved_note;
 472   1              wait_for_input();
 473   1              pos[2]=recieved_note;
 474   1              recieved_note=0;
 475   1              map[(pos[0]/128)+(pos[0]%128)/16][(pos[0]%128)%16] = 95;// 95 = /
 476   1              if(pos[1]!='e')
 477   1                      map[(pos[1]/128)+(pos[1]%128)/16][(pos[1]%128)%16] = 95;
 478   1              if(pos[2]!='e')
 479   1                      map[(pos[2]/128)+(pos[2]%128)/16][(pos[2]%128)%16] = 95;
 480   1      }
 481          
 482          
 483          
 484          //fill map with blank boxes.
 485          void Init_map()
 486          {
 487   1              short i=0;
 488   1              short j=0;
 489   1              for(j=0;j<4;j++)
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 9   

 490   1              {
 491   2                      for(i=0;i<16;i++)
 492   2                      {
 493   3                              map[j][i]= 219;//219 represent unchecked box
 494   3                      }
 495   2              }       
 496   1              
 497   1      }
 498          //print the map by the right screen. 
 499          //screen 2 = upper half. 
 500          //sceren 3 = bottom half.
 501          void print_map(int screen)
 502          {
 503   1              short i;
 504   1              if (screen==2 || screen==3)
 505   1              {
 506   2                      
 507   2                              for (i=0;i<16;i++)
 508   2                              {
 509   3                                      LCD_BF();
 510   3                                      LCD_DAT(map[(0+2*(screen/3))][i]);
 511   3                                      LCD_BF();
 512   3                              }
 513   2                              LCD_GOTO(0x40);
 514   2                              for (i=0;i<16;i++)
 515   2                              {
 516   3                                      LCD_BF();
 517   3                                      LCD_DAT(map[1+2*(screen/3)][i]);
 518   3                                      LCD_BF();
 519   3                              }
 520   2              }
 521   1      }
 522          
 523          
 524          void end() interrupt 0
 525          {
 526   1              wait_for_input();
 527   1              screen_end(recieved_note);
 528   1      }
 529          
 530          void screen_end(char win)
 531          {
 532   1              char* message;
 533   1              if (win=='w')
 534   1              {
 535   2                      message = "WINNER!";
 536   2              }
 537   1              else if(win=='l')
 538   1              {
 539   2                      message = "LOOSER!";
 540   2              }
 541   1              else
 542   1              {
 543   2                      message = "ERROR!";
 544   2              }
 545   1              LCD_CLRS(); // clears the display
 546   1              LCD_BF();// wait untill the LCD is no longer busy
 547   1              LCD_CMD(0x02);// move the cursor home
 548   1              LCD_BF();// wait untill the LCD is no longer busy
 549   1              LCD_MSG(message);
 550   1              LCD_BF();// wait untill the LCD is no longer busy
 551   1              delay(4);//wait 4 seconds.
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/26/2019 10:14:16 PAGE 10  

 552   1              LCD_CLRS();
 553   1              LCD_BF();// wait untill the LCD is no longer busy
 554   1              LCD_MSG("please press");
 555   1              LCD_BF();
 556   1              LCD_GOTO(0x40);
 557   1              LCD_BF();
 558   1              LCD_MSG("reset button!.");
 559   1              LCD_BF();// wait untill the LCD is no longer busy
 560   1              while(1);
 561   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2248    ----
   CONSTANT SIZE    =    143    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     76      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
