C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BATTLESHIPS
OBJECT MODULE PLACED IN battleships.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe battleships.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          
   2          
   3          //#include "C8051F020.h"                  // Include register definition file.
   4          #include "User_Interface_def.h"
   5          #include "battleships.h"
   6          //----------------------------- related Functions --------------------------------
   7          
   8          void main()
   9          {
  10   1              Init_Device();
  11   1              Init_LCD();
  12   1              Init_map();
  13   1              Main_loop();
  14   1              
  15   1              
  16   1      
  17   1      }
  18          void Main_loop()
  19          {
  20   1              while(1)
  21   1              {
  22   2                      switch(screen_num)
  23   2                      {
  24   3                              case 0:
  25   3                                      start_screen();
  26   3                                      switch_difficulty();
  27   3                                      counting_screen();
  28   3                                      break;
  29   3                              case 1:
  30   3                                      screen_data();
  31   3                                      break;
  32   3                              case 2:
  33   3                                      screen_map_one();
  34   3                                      break;
  35   3                              case 3:
  36   3                                      screen_map_two();
  37   3                                      break;
  38   3                              default://bug - > print that there is a problem. ask the player to reset the game. "Error screen".
  39   3                                      break;
  40   3                      }
  41   2              }
  42   1      }
  43          
  44          
  45          void screen_data()
  46          {
  47   1              char key=0;
  48   1              while(1)
  49   1              {
  50   2                      //get_data();
  51   2                      print_current_status();
  52   2                      key=GET_KEY();
  53   2                      if(key==5)
  54   2                      {
  55   3                              screen_num=2;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 2   

  56   3                              return;
  57   3                      }
  58   2              }       
  59   1      }
  60          
  61          void print_current_status()
  62          {
  63   1              char miss;
  64   1              LCD_CLRS(); // clears the display
  65   1              LCD_BF();// wait untill the LCD is no longer busy
  66   1              LCD_CMD(0x02);// move the cursor home
  67   1              LCD_BF();// wait untill the LCD is no longer busy
  68   1              LCD_MSG("Time left: ");
  69   1              LCD_BF();// wait untill the LCD is no longer busy
  70   1              LCD_MSG(game_timer);
  71   1              LCD_BF();// wait untill the LCD is no longer busy
  72   1              LCD_GOTO(0x40);
  73   1              LCD_BF();// wait untill the LCD is no longer busy
  74   1              LCD_MSG("Misses left: ");
  75   1              LCD_BF();// wait untill the LCD is no longer busy
  76   1              miss=miss_cnt/10;
  77   1              LCD_DAT(miss+'0');
  78   1              LCD_BF();
  79   1              miss=miss_cnt%10;
  80   1              LCD_DAT(miss+'0');
  81   1              LCD_BF();// wait untill the LCD is no longer busy
  82   1      }
  83          
  84          void get_data()
  85          {
  86   1              char s[3];
  87   1              int i;
  88   1              //send 'd', wait for input 4 times
  89   1              send_char('d');
  90   1              for(i=0;i<3;i++)
  91   1              {
  92   2                      wait_for_input();
  93   2                      s[i]=recieved_note;
  94   2              }
  95   1              recieved_note=0;
  96   1              game_timer[0]=(s[0]/10) + '0';
  97   1              game_timer[1]=(s[0]%10) + '0';
  98   1              game_timer[2]=':';
  99   1              game_timer[3]=(s[1]/10) + '0';
 100   1              game_timer[4]=(s[1]%10) + '0';
 101   1              miss_cnt = (s[2]/10)*10 + (s[2]%10);
 102   1      }
 103          
 104          //check if there is avaible data.
 105          void check_input_uart()
 106          {
 107   1              if (!RI0)
 108   1                      return;
 109   1              recieved_note = SBUF0;
 110   1              RI0=0;
 111   1      }
 112          //wait for data.
 113          void wait_for_input()
 114          {
 115   1              while(!RI0);
 116   1              recieved_note = SBUF0;
 117   1              RI0=0;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 3   

 118   1      }
 119          //send data to ARM.
 120          void send_char(char c)
 121          {
 122   1              TI0 = 0;
 123   1              SBUF0=  c;
 124   1              while(!TI0);
 125   1              TI0= 0;
 126   1              //#devnote: add :check if the arm got the tarsmission
 127   1      }
 128          //wait for "secs" seconds.
 129          //#devnote: need to be fixed. there is a new oscilator frequency.
 130          void delay(int secs)
 131          {
 132   1              int pu = secs/(6*10^(-6));
 133   1              int t0 = 0xFFFF-pu;
 134   1              TL0=(t0%(0xFF));
 135   1              TH0=(t0/(0xFF));
 136   1              TR0 = 1;        //START COUNTING
 137   1              while(!TF0);    //DELAY UNTIL OF
 138   1      }
 139          
 140          void Init_LCD()
 141          {
 142   1              LCD_BF(); // wait untill the LCD is no longer busy
 143   1              LCD_INIT();// initialize the LCD to 8 bit mode
 144   1              LCD_BF();// wait untill the LCD is no longer busy
 145   1              LCD_CMD(0x06); // curser moves from left to right
 146   1              LCD_BF();// wait untill the LCD is no longer busy
 147   1              LCD_CLRS(); // clears the display
 148   1              LCD_BF();// wait untill the LCD is no longer busy
 149   1              LCD_CMD(0x02);// move the cursor home
 150   1              LCD_BF();// wait untill the LCD is no longer busy
 151   1              
 152   1      }
 153          
 154          void start_screen()
 155          {
 156   1              LCD_CLRS(); // clears the display
 157   1              LCD_BF();// wait untill the LCD is no longer busy
 158   1              LCD_MSG("BattleShips!");
 159   1              LCD_BF();// wait untill the LCD is no longer busy
 160   1              delay(2);
 161   1              LCD_CLRS(); // clears the display
 162   1              LCD_BF();// wait untill the LCD is no longer busy
 163   1      }
 164          
 165          
 166          void switch_difficulty()
 167          {
 168   1              char key;
 169   1              LCD_CMD(0x02);// move the cursor home
 170   1              LCD_BF();// wait untill the LCD is no longer busy
 171   1              LCD_MSG("Please choose");
 172   1              LCD_BF();// wait untill the LCD is no longer busy
 173   1              LCD_GOTO(0x40);
 174   1              LCD_BF();// wait untill the LCD is no longer busy
 175   1              LCD_MSG("difficulty:");
 176   1              LCD_BF();// wait untill the LCD is no longer busy
 177   1              PRESSED_KEY();  //wait until pressing
 178   1              key = GET_KEY();        //save the key pressed
 179   1              KEY_RELEASE();          //wait until releasing
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 4   

 180   1              LCD_DAT(ASCII_CONV(key));
 181   1              LCD_BF();// wait untill the LCD is no longer busy
 182   1              set_difficulty(key);
 183   1              delay(2);
 184   1              //#devnote: add :check if difficulty
 185   1      }
 186          
 187          void set_difficulty(char difficulty)
 188          {
 189   1              //#devnote: add :check if difficulty is legit. if not, ask the player to re-enter difficulty level
 190   1              send_char(difficulty);//let the arm decide what difficulty parameters should be.
 191   1      }
 192          
 193          void counting_screen()
 194          {
 195   1              LCD_CLRS(); // clears the display
 196   1              LCD_BF();// wait untill the LCD is no longer busy
 197   1              LCD_MSG("3");
 198   1              LCD_BF();// wait untill the LCD is no longer busy
 199   1              delay(1);
 200   1              LCD_CLRS(); // clears the display
 201   1              LCD_BF();// wait untill the LCD is no longer busy
 202   1              LCD_MSG("2");
 203   1              LCD_BF();// wait untill the LCD is no longer busy
 204   1              delay(1);
 205   1              LCD_CLRS(); // clears the display
 206   1              LCD_BF();// wait untill the LCD is no longer busy
 207   1              LCD_MSG("1");
 208   1              LCD_BF();// wait untill the LCD is no longer busy
 209   1              delay(1);
 210   1              LCD_CLRS(); // clears the display
 211   1              LCD_BF();// wait untill the LCD is no longer busy
 212   1              LCD_MSG("GO!");
 213   1              LCD_BF();// wait untill the LCD is no longer busy
 214   1              delay(1);
 215   1              LCD_CLRS(); // clears the display
 216   1              LCD_BF();// wait untill the LCD is no longer busy
 217   1              send_char('s');//indicate the ARM the game starts now.
 218   1              screen_num=1;//change to screen_data.
 219   1      }
 220          
 221          void Reset_isr() interrupt 1
 222          {
 223   1              game_timer[0]='0';
 224   1              game_timer[1]='0';
 225   1              game_timer[3]='0';
 226   1              game_timer[4]='0';
 227   1              miss_cnt=0;
 228   1              TI0 = 0;
 229   1              send_char('r'); //sending "Reset" to ARM.
 230   1              Init_LCD();
 231   1              KEPAD_INIT();   // initialize the keypad
 232   1              screen_num=0;
 233   1              recieved_note=0;
 234   1              cursor =0;
 235   1              Init_map();
 236   1              Main_loop();//#devnote: when will the interrupt end ? there is a bug !.
 237   1      }
 238          
 239          void screen_map_one()
 240          {
 241   1              char key=0; //used to read input from the user keyboard.
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 5   

 242   1              LCD_BF();// wait untill the LCD is no longer busy
 243   1              LCD_CLRS(); // clears the display
 244   1              LCD_BF();// wait untill the LCD is no longer busy
 245   1              //---------> move cursor to right place
 246   1              if(cursor>15)
 247   1                      LCD_GOTO(cursor + 0x30);
 248   1              else
 249   1                      LCD_GOTO(cursor);
 250   1              LCD_BF();// wait untill the LCD is no longer busy
 251   1              print_map(2);
 252   1              while(1) // kind of a main loop
 253   1              {
 254   2                      key = GET_KEY();
 255   2                      if(key!=0) 
 256   2                      {
 257   3                              switch(key)
 258   3                              {
 259   4                              case 1://move cursor up. may chagnge the screen.
 260   4                                      if (cursor<=15)
 261   4                                      {
 262   5                                              screen_num=1;//change to screen_data.
 263   5                                              return;
 264   5                                      }
 265   4                                      cursor-=16;//go to upper line
 266   4                                      LCD_GOTO(cursor);
 267   4                                      break;
 268   4                              case 4://move cursor left.
 269   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 270   4                                              break;
 271   4                                      cursor--;
 272   4                                      LCD_BF();
 273   4                                      //------------>move left
 274   4                                      if(cursor>15)
 275   4                                              LCD_GOTO(cursor + 0x30);
 276   4                                      else
 277   4                                              LCD_GOTO(cursor);
 278   4                                      break;
 279   4                              case 5://move cursor down. may change screen.
 280   4                                      if (cursor>=16)
 281   4                                      {
 282   5                                              cursor-=16;
 283   5                                              screen_num=3;//go to bottom half of the map.
 284   5                                              return;
 285   5                                      }
 286   4                                      cursor+=16;
 287   4                                      LCD_BF();
 288   4                                      LCD_GOTO(cursor + 0x30);
 289   4                                      break;
 290   4                              case 6://move cursor right.
 291   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 292   4                                              break;
 293   4                                      cursor++;
 294   4                                      LCD_BF();
 295   4                                      //------------>move right
 296   4                                      if(cursor>15)
 297   4                                              LCD_GOTO(cursor + 0x30);
 298   4                                      else
 299   4                                              LCD_GOTO(cursor);
 300   4                                      break;
 301   4                              }
 302   3                      }
 303   2                      key=0;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 6   

 304   2                      
 305   2              }
 306   1              
 307   1      
 308   1      }
 309          //fill map with blank boxes.
 310          void Init_map()
 311          {
 312   1              int i=0;
 313   1              int j=0;
 314   1              for(j=0;j<4;j++)
 315   1              {
 316   2                      for(i=0;i<16;i++)
 317   2                      {
 318   3                              map[j][i]= 219;//219 represent unchecked box
 319   3                      }
 320   2              }       
 321   1              
 322   1      }
 323          //print the map by the right screen. 
 324          //screen 2 = upper half. 
 325          //sceren 3 = bottom half.
 326          void print_map(int screen)
 327          {
 328   1              int i;
 329   1              if (screen==2 || screen==3)
 330   1              {
 331   2                      
 332   2                              for (i=0;i<16;i++)
 333   2                              {
 334   3                                      LCD_BF();
 335   3                                      LCD_DAT(map[(0+2*(screen/3))][i]);
 336   3                                      LCD_BF();
 337   3                              }
 338   2                              LCD_GOTO(0x40);
 339   2                              for (i=0;i<16;i++)
 340   2                              {
 341   3                                      LCD_BF();
 342   3                                      LCD_DAT(map[1+2*(screen/3)][i]);
 343   3                                      LCD_BF();
 344   3                              }
 345   2              }
 346   1      }
 347          
 348          
 349          void end() interrupt 0
 350          {
 351   1              wait_for_input();
 352   1              screen_end(recieved_note);
 353   1      }
 354          
 355          void screen_end(char win)
 356          {
 357   1              if (win=='w')
 358   1              {
 359   2                      //#devnote:ending winner screen.
 360   2                      //#devnote:request the player to hit "reset".
 361   2              }
 362   1              else if(win=='l')
 363   1              {
 364   2                      //#devnote:ending winner screen.
 365   2                      //#devnote:request the player to hit "reset".
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/25/2019 12:47:00 PAGE 7   

 366   2              }
 367   1              else
 368   1              {
 369   2                      //#devnote: not sure. we can call screen_end again or raise screen_error and ask for a 'reset'.
 370   2              }
 371   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1273    ----
   CONSTANT SIZE    =     75    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     76      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
