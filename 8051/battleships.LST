C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BATTLESHIPS
OBJECT MODULE PLACED IN battleships.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe battleships.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------//
   2          //User_Interface_Functions.c
   3          //----------------------------------------------------------------------------
   4          //  Copyright (C) 2016 BRAUDE COLLEGE  
   5          //  Electronics & Elictrical Engineering Department
   6          //  All rights reserved.
   7          //  Owner               :  Dr. Fadil Tareef
   8          //  FILE NAME   :  User_Interface_Functions.c 
   9          //  DATE         :  23 DEC 2016
  10          //  TARGET MCU   :  C8051F020
  11          //  DESCRIPTION  :  This file contains LCD and KEPAD Interface Functions Implementation.
  12          //                                      P1 is used for the control signals, P1.0 = E, P1.1 = RW, P1.2 = RS, output only
  13          //                                      P2 is used for data: P2.7 is read to get the status of the LCD (BF)
  14          //                                      P2 must be configured as bidirectional (open-drain) 
  15          //                                      and set to FF (or at least 80) before reading the status of P2.7
  16          //                                      P3 is used for KEPAD interface.
  17          //                                      P3.0-P3.3 connected to the COLUMNS of the KEPAD, input pins.
  18          //                                      P3.4-P3.7 connected to the ROWS of the KEPAD, output pins.
  19          //                                
  20          //      NOTES: This file used in the LCD.c file.
  21          //                 This file updated for Keil C compiler and C8051F020.
  22          //-----------------------------------------------------------------------------
  23          
  24          //#include "C8051F020.h"                  // Include register definition file.
  25          #include "User_Interface_def.h"
  26          #include "battleships.h"
  27          //----------------------------- related Functions --------------------------------
  28          char first = 't';
  29          void main()
  30          {
  31   1      
  32   1              if (first=='f') send_char('r');//tell the ARM to Reset.
  33   1              first='f';
  34   1              Init_Device();
  35   1              Init_LCD();
  36   1              Init_map();
  37   1              Main_loop();
  38   1      }
  39          void Main_loop()
  40          {
  41   1              while(1)
  42   1              {
  43   2                      switch(screen_num)
  44   2                      {
  45   3                              case 0:
  46   3                                      //start
  47   3                                      start_screen();
  48   3                                      break;
  49   3                              case 1:
  50   3                                      //chose difficulty level
  51   3                                      switch_difficulty();
  52   3                                      break;
  53   3                              case 2:
  54   3                                      counting_screen();
  55   3                                      break;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 2   

  56   3                              case 3:
  57   3                                      //show time and missiles left
  58   3                                      screen_data();                          
  59   3                                      break;
  60   3                              case 4:
  61   3                                      //upper half of map
  62   3                                      screen_map_one();
  63   3                                      break;
  64   3                              case 5:
  65   3                                      //lower half of map
  66   3                                      screen_map_two();
  67   3                                      break;
  68   3                              case 6:
  69   3                                      //end
  70   3                                      screen_end(w);
  71   3                                      break;
  72   3                              default://bug - > print that there is a problem. ask the player to reset the game. "Error screen".
  73   3                                      break;
  74   3                      }
  75   2              }
  76   1      }
  77          
  78          
  79          void screen_data()
  80          {
  81   1              char key=0;
  82   1              while(1)
  83   1              {
  84   2                      get_data();//get time and missiles left from ARM
  85   2                      if(w!=0)//if we lost\won
  86   2                      {
  87   3                      screen_num=6;//go to end
  88   3                      return;
  89   3                      }
  90   2                      print_current_status();//print time and missiles left
  91   2                      key=GET_KEY();
  92   2                      large_delay(130);
  93   2                      if(key==5)//if user asks to get down to the upper half of the map
  94   2                      {
  95   3                              screen_num=4;
  96   3                              return;
  97   3                      }
  98   2              }       
  99   1      }
 100          
 101          void print_current_status()
 102          {
 103   1              LCD_CLRS(); // clears the display
 104   1              LCD_BF();// wait untill the LCD is no longer busy
 105   1              LCD_CMD(0x02);// move the cursor home
 106   1              LCD_BF();// wait untill the LCD is no longer busy
 107   1              LCD_MSG("Time left: ");
 108   1              LCD_BF();// wait untill the LCD is no longer busy
 109   1              LCD_MSG(game_timer);
 110   1              LCD_BF();// wait untill the LCD is no longer busy
 111   1              LCD_GOTO(0x40);
 112   1              LCD_BF();// wait untill the LCD is no longer busy
 113   1              LCD_MSG("Misses left: ");
 114   1              LCD_BF();// wait untill the LCD is no longer busy
 115   1              LCD_DAT((miss_cnt/10)+'0');
 116   1              LCD_BF();
 117   1              LCD_DAT((miss_cnt%10)+'0');
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 3   

 118   1              LCD_BF();// wait untill the LCD is no longer busy
 119   1      }
 120          
 121          void get_data()
 122          {
 123   1              char s[3];
 124   1              short i;
 125   1              //send 'd', wait for input 4 times
 126   1              check_input_uart();
 127   1              check_end();
 128   1                      if(w!=0)
 129   1                              return;
 130   1              send_char('d');//ask for data
 131   1              for(i=0;i<3;i++)//get data
 132   1              {
 133   2                      wait_for_input();
 134   2                      check_end();
 135   2                      if(w!=0)
 136   2                              return;
 137   2                      s[i]=recieved_note;
 138   2              }
 139   1              //set time and missiles left
 140   1              recieved_note=0;
 141   1              game_timer[0]=(s[0]/10) + '0';
 142   1              game_timer[1]=(s[0]%10) + '0';
 143   1              game_timer[2]=':';
 144   1              game_timer[3]=(s[1]/10) + '0';
 145   1              game_timer[4]=(s[1]%10) + '0';
 146   1              miss_cnt = s[2];
 147   1      }
 148          
 149          //check if there is avaible data.
 150          void check_input_uart()
 151          {
 152   1              if (!RI0)
 153   1                      return;
 154   1              recieved_note = SBUF0;
 155   1              RI0=0;
 156   1      }
 157          //wait for data.
 158          void wait_for_input()
 159          {
 160   1              while(!RI0);
 161   1              recieved_note = SBUF0;
 162   1              RI0=0;
 163   1      }
 164          //send data to ARM.
 165          void send_char(char c)
 166          {
 167   1              TI0 = 0;
 168   1              SBUF0=  c;
 169   1              while(!TI0);
 170   1              TI0= 0;
 171   1      }
 172          //wait for "secs" seconds.
 173          void delay(int secs)
 174          {
 175   1              short j=0;
 176   1              short i=0;
 177   1              for (;j<secs;j++)
 178   1              {
 179   2                      for (;i<28;i++)
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 4   

 180   2                      {
 181   3                              TR0 = 1;        //START COUNTING
 182   3                              while(!TF0);    //DELAY
 183   3                              TF0=0;
 184   3                      }
 185   2              }
 186   1      }
 187          
 188          void Init_LCD()
 189          {
 190   1              red=0;
 191   1              green=0;
 192   1              yellow=0;
 193   1              blue=0;
 194   1              LCD_BF(); // wait untill the LCD is no longer busy
 195   1              LCD_INIT();// initialize the LCD to 8 bit mode
 196   1              LCD_BF();// wait untill the LCD is no longer busy
 197   1              LCD_CMD(0x06); // curser moves from left to right
 198   1              LCD_BF();// wait untill the LCD is no longer busy
 199   1              LCD_CLRS(); // clears the display
 200   1              LCD_BF();// wait untill the LCD is no longer busy
 201   1              LCD_CMD(0x02);// move the cursor home
 202   1              LCD_BF();// wait untill the LCD is no longer busy
 203   1              
 204   1      }
 205          
 206          void start_screen()
 207          {
 208   1              LCD_CLRS(); // clears the display
 209   1              LCD_BF();// wait untill the LCD is no longer busy
 210   1              LCD_MSG("BattleShips!");
 211   1              LCD_BF();// wait untill the LCD is no longer busy
 212   1              delay(2);
 213   1              LCD_CLRS(); // clears the display
 214   1              LCD_BF();// wait untill the LCD is no longer busy
 215   1              screen_num=1;
 216   1      }
 217          
 218          
 219          void switch_difficulty()
 220          {
 221   1              char key;
 222   1              LCD_CLRS(); // clears the display
 223   1              LCD_CMD(0x02);// move the cursor home
 224   1              LCD_BF();// wait untill the LCD is no longer busy
 225   1              LCD_MSG("Please choose");
 226   1              LCD_BF();// wait untill the LCD is no longer busy
 227   1              LCD_GOTO(0x40);
 228   1              LCD_BF();// wait untill the LCD is no longer busy
 229   1              LCD_MSG("difficulty:");
 230   1              LCD_BF();// wait untill the LCD is no longer busy
 231   1              PRESSED_KEY();  //wait until pressing
 232   1              key = GET_KEY();        //save the key pressed
 233   1              KEY_RELEASE();          //wait until releasing
 234   1              LCD_DAT(ASCII_CONV(key));
 235   1              LCD_BF();// wait untill the LCD is no longer busy
 236   1              screen_num=2;
 237   1              set_difficulty(key+1);
 238   1              delay(2);
 239   1      }
 240          
 241          void set_difficulty(char difficulty)
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 5   

 242          {
 243   1              //difficulty level range : 1-3 (on keyboard). 
 244   1              if (difficulty>3)
 245   1              {
 246   2                      delay(1);
 247   2                      screen_num=1;
 248   2                      LCD_CLRS(); // clears the display
 249   2                      LCD_CMD(0x02);// move the cursor home
 250   2                      LCD_BF();// wait untill the LCD is no longer busy
 251   2                      LCD_MSG("range: 1-3");
 252   2                      LCD_BF();// wait untill the LCD is no longer busy
 253   2                      delay(1);
 254   2                      return;
 255   2              }
 256   1              send_char(difficulty);//let the arm decide what difficulty parameters should be.
 257   1      }
 258          
 259          void counting_screen()
 260          {
 261   1              wait_for_input();
 262   1              recieved_note=0;
 263   1              LCD_CLRS(); // clears the display
 264   1              LCD_BF();// wait untill the LCD is no longer busy
 265   1              LCD_MSG("3");
 266   1              LCD_BF();// wait untill the LCD is no longer busy
 267   1              delay(1);
 268   1              LCD_CLRS(); // clears the display
 269   1              LCD_BF();// wait untill the LCD is no longer busy
 270   1              LCD_MSG("2");
 271   1              LCD_BF();// wait untill the LCD is no longer busy
 272   1              delay(1);
 273   1              LCD_CLRS(); // clears the display
 274   1              LCD_BF();// wait untill the LCD is no longer busy
 275   1              LCD_MSG("1");
 276   1              LCD_BF();// wait untill the LCD is no longer busy
 277   1              delay(1);
 278   1              LCD_CLRS(); // clears the display
 279   1              LCD_BF();// wait untill the LCD is no longer busy
 280   1              LCD_MSG("GO!");
 281   1              LCD_BF();// wait untill the LCD is no longer busy
 282   1              delay(1);
 283   1              LCD_CLRS(); // clears the display
 284   1              LCD_BF();// wait untill the LCD is no longer busy
 285   1              send_char('s');//indicate the ARM the game starts now.
 286   1              screen_num=3;//change to screen_data.
 287   1      }
 288          //upper half of the map
 289          void screen_map_one()
 290          {
 291   1              char key=0; //used to read input from the user keyboard.
 292   1              LCD_BF();// wait untill the LCD is no longer busy
 293   1              LCD_CLRS(); // clears the display
 294   1              LCD_BF();// wait untill the LCD is no longer busy
 295   1              LCD_GOTO(0x00);
 296   1              LCD_BF();
 297   1              print_map(screen_num);
 298   1              //---------> move cursor to right place
 299   1              if(cursor>15)
 300   1                      LCD_GOTO(cursor + 0x30);
 301   1              else
 302   1                      LCD_GOTO(cursor);
 303   1              LCD_BF();// wait untill the LCD is no longer busy
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 6   

 304   1              while(1) // kind of a main loop
 305   1              {
 306   2                      key = GET_KEY();
 307   2                      if(key!=0) 
 308   2                      {
 309   3                              red=0;
 310   3                              green=0;
 311   3                              yellow=0;
 312   3                              blue=0;
 313   3                              switch(key)
 314   3                              {
 315   4                              case 1://move cursor up. may chagnge the screen.
 316   4                                      if (cursor<=15)
 317   4                                      {
 318   5                                              screen_num=3;//change to screen_data.
 319   5                                              return;
 320   5                                      }
 321   4                                      cursor-=16;//go to upper line
 322   4                                      LCD_GOTO(cursor);
 323   4                                      break;
 324   4                              case 4://move cursor left.
 325   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 326   4                                      {
 327   5                                              cursor+=15;
 328   5                                              LCD_BF();
 329   5                                              LCD_GOTO(cursor+3*(cursor/16));
 330   5                                              break;
 331   5                                      }
 332   4                                      cursor--;
 333   4                                      LCD_BF();
 334   4                                      //------------>move left
 335   4                                      if(cursor>15)
 336   4                                              LCD_GOTO(cursor + 0x30);
 337   4                                      else
 338   4                                              LCD_GOTO(cursor);
 339   4                                      break;
 340   4                              case 5://move cursor down. may change screen.
 341   4                                      if (cursor>=16)
 342   4                                      {
 343   5                                              cursor-=16;
 344   5                                              screen_num=5;//go to bottom half of the map.
 345   5                                              return;
 346   5                                      }
 347   4                                      cursor+=16;
 348   4                                      LCD_BF();
 349   4                                      LCD_GOTO(cursor + 0x30);
 350   4                                      break;
 351   4                              case 6://move cursor right.
 352   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 353   4                                      {
 354   5                                              cursor-=15;
 355   5                                              LCD_BF();
 356   5                                              LCD_GOTO(cursor+3*(cursor/16));
 357   5                                              break;
 358   5                                      }
 359   4                                      cursor++;
 360   4                                      LCD_BF();
 361   4                                      //------------>move right
 362   4                                      if(cursor>15)
 363   4                                              LCD_GOTO(cursor + 0x30);
 364   4                                      else
 365   4                                              LCD_GOTO(cursor);
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 7   

 366   4                                      break;
 367   4                              }
 368   3                      }
 369   2                      key=0;
 370   2                      //if a win or lose message came
 371   2                      check_input_uart();
 372   2                      check_end();
 373   2                      if(w!=0)
 374   2                              return;
 375   2                      //hit
 376   2                      if(SW4 == 0)
 377   2                      {
 378   3                              if(map[cursor/16][cursor%16] =='X'||map[cursor/16][cursor%16]=='O') return;
 379   3                              //independently because long binary sentence arn't working well.
 380   3                              if(map[cursor/16][cursor%16]=='S')return;
 381   3                              red=0;
 382   3                              green=0;
 383   3                              yellow=0;
 384   3                              blue=0;
 385   3                              send_char((char)cursor+1);//send to ARM the hit location.
 386   3                              wait_for_input();//wait for ARM to respond.
 387   3                              if(recieved_note == 'h')//if hit
 388   3                              {
 389   4                                      green=1;
 390   4                                      recieved_note=0;
 391   4                                      map[cursor/16][cursor%16] = 'X';
 392   4                                      LCD_BF();
 393   4                                      LCD_DAT('X');
 394   4                                      LCD_BF();
 395   4                                      LCD_CMD(0x10);
 396   4                              }
 397   3                              else if(recieved_note == 'm')//if miss
 398   3                              {
 399   4                                      red=1;
 400   4                                      recieved_note=0;
 401   4                                      map[cursor/16][cursor%16] = 'O';
 402   4                                      LCD_BF();
 403   4                                      LCD_DAT('O');
 404   4                                      LCD_BF();
 405   4                                      LCD_CMD(0x10);
 406   4                              }
 407   3                              else if(recieved_note == 'p')//if falles ship
 408   3                              {
 409   4                                      red=1;
 410   4                                      green=1;
 411   4                                      yellow=1;
 412   4                                      blue=1;
 413   4                                      recieved_note=0;
 414   4                                      update_fallen_ship();
 415   4                                      return;
 416   4                              }
 417   3                              check_end();
 418   3                              if(w!=0)
 419   3                                      return;
 420   3                              while(SW4 == 0);//wait untill switch4 in released.
 421   3                      }
 422   2              }
 423   1      }
 424          //lower half of the map
 425          void screen_map_two()
 426          {
 427   1              char key=0; //used to read input from the user keyboard.
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 8   

 428   1              LCD_BF();// wait untill the LCD is no longer busy
 429   1              LCD_CLRS(); // clears the display
 430   1              LCD_BF();// wait untill the LCD is no longer busy
 431   1              LCD_GOTO(0x00);
 432   1              LCD_BF();
 433   1              print_map(screen_num);
 434   1              //---------> move cursor to right place
 435   1              if(cursor>15)
 436   1                      LCD_GOTO(cursor + 0x30);
 437   1              else
 438   1                      LCD_GOTO(cursor);
 439   1              LCD_BF();// wait untill the LCD is no longer busy
 440   1              while(1) // kind of a main loop
 441   1              {
 442   2                      key = GET_KEY();
 443   2                      if(key!=0) 
 444   2                      {
 445   3                              red=0;
 446   3                              green=0;
 447   3                              yellow=0;
 448   3                              blue=0;
 449   3                              switch(key)
 450   3                              {
 451   4                              case 1://move cursor up. may chagnge the screen.
 452   4                                      if (cursor<=15)
 453   4                                      {
 454   5                                              screen_num=4;//change to screen_data.
 455   5                                              cursor+=16;
 456   5                                              return;
 457   5                                      }
 458   4                                      cursor-=16;//go to upper line
 459   4                                      LCD_GOTO(cursor);
 460   4                                      break;
 461   4                              case 4://move cursor left.
 462   4                                      if (cursor==0 || cursor==16)//can't go behind the screeen.
 463   4                                      {
 464   5                                              cursor+=15;
 465   5                                              LCD_BF();
 466   5                                              LCD_GOTO(cursor+3*(cursor/16));
 467   5                                              break;
 468   5                                      }
 469   4                                      cursor--;
 470   4                                      LCD_BF();
 471   4                                      //------------>move left
 472   4                                      if(cursor>15)
 473   4                                              LCD_GOTO(cursor + 0x30);
 474   4                                      else
 475   4                                              LCD_GOTO(cursor);
 476   4                                      break;
 477   4                              case 5://move cursor down. may change screen.
 478   4                                      if (cursor>=16)
 479   4                                      {
 480   5                                              return;
 481   5                                      }
 482   4                                      cursor+=16;
 483   4                                      LCD_BF();
 484   4                                      LCD_GOTO(cursor + 0x30);
 485   4                                      break;
 486   4                              case 6://move cursor right.
 487   4                                      if (cursor==15 || cursor==31)//can't go behind the screeen.
 488   4                                      {
 489   5                                              cursor-=15;
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 9   

 490   5                                              LCD_BF();
 491   5                                              LCD_GOTO(cursor+3*(cursor/16));
 492   5                                              break;
 493   5                                      }
 494   4                                      cursor++;
 495   4                                      LCD_BF();
 496   4                                      //------------>move right
 497   4                                      if(cursor>15)
 498   4                                              LCD_GOTO(cursor + 0x30);
 499   4                                      else
 500   4                                              LCD_GOTO(cursor);
 501   4                                      break;
 502   4                              }
 503   3                      }
 504   2                      key=0;
 505   2                      check_input_uart();//if a win or lose message came
 506   2                      check_end();
 507   2                      if(w!=0)
 508   2                              return;
 509   2                      //hit
 510   2                      if(SW4 == 0)
 511   2                      {
 512   3                              if(map[(cursor/16)+2][cursor%16] =='X'||map[(cursor/16)+2][cursor%16]=='O') return;
 513   3                              if(map[(cursor/16)+2][cursor%16]=='S')return;
 514   3                              red=0;
 515   3                              green=0;
 516   3                              yellow=0;
 517   3                              blue=0;
 518   3                              send_char((char)cursor+33);//send to ARM the hit location. +32 offset indicate 2' screen
 519   3                              wait_for_input();//wait for ARM to respond.
 520   3                              if(recieved_note == 'h')//if hit
 521   3                              {
 522   4                                      green=1;
 523   4                                      recieved_note=0;
 524   4                                      map[cursor/16+2][cursor%16] = 'X';
 525   4                                      LCD_BF();
 526   4                                      LCD_DAT('X');
 527   4                                      LCD_BF();
 528   4                                      LCD_CMD(0x10);
 529   4                              }
 530   3                              else if(recieved_note == 'm')//if miss
 531   3                              {
 532   4                                      red=1;
 533   4                                      recieved_note=0;
 534   4                                      map[cursor/16+2][cursor%16] = 'O';
 535   4                                      LCD_BF();
 536   4                                      LCD_DAT('O');
 537   4                                      LCD_BF();
 538   4                                      LCD_CMD(0x10);
 539   4                              }
 540   3                              else if(recieved_note == 'p')//falles ship
 541   3                              {
 542   4                                      red=1;
 543   4                                      green=1;
 544   4                                      yellow=1;
 545   4                                      blue=1;
 546   4                                      recieved_note=0;
 547   4                                      update_fallen_ship();
 548   4                                      return;
 549   4                              }
 550   3                              check_end();
 551   3                              if(w!=0)
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 10  

 552   3                                      return;
 553   3                              while(SW4 == 0);
 554   3                      }
 555   2              }
 556   1      }
 557          //get 3 pos of the falles ship from the uart.
 558          void update_fallen_ship()
 559          {
 560   1              char pos[3];
 561   1              int i=0;
 562   1              for(;i<3;i++)//get cordinates of the fallen ship
 563   1              {
 564   2                      wait_for_input();
 565   2                      check_end();
 566   2                      if(w!=0)
 567   2                              return;
 568   2                      pos[i]=recieved_note;
 569   2              }
 570   1              //update on map
 571   1              recieved_note=0;
 572   1              map[pos[0]/16][pos[0]%16] = 'S';//'S' = fallen ship
 573   1              if(pos[1]!='e')
 574   1                      map[pos[1]/16][pos[1]%16] = 'S';
 575   1              if(pos[2]!='e')
 576   1                      map[pos[2]/16][pos[2]%16] = 'S';
 577   1      }
 578          
 579          
 580          void check_end()
 581          {
 582   1              if(recieved_note =='w'||recieved_note=='l')
 583   1              {
 584   2                      w=recieved_note;
 585   2                      screen_num=6;
 586   2                      return;
 587   2              }
 588   1      }
 589          
 590          //fill map with blanks .
 591          void Init_map()
 592          {
 593   1              short i=0;
 594   1              short j=0;
 595   1              for(j=0;j<2;j++)
 596   1              {
 597   2                      for(i=0;i<16;i++)
 598   2                      {
 599   3                              map[j][i]= '-';//represent "unchecked"  = '-' in uppper half map
 600   3                              map[j+2][i]='+';//represent "unchecked"  = '+' in bottom half map
 601   3                      }
 602   2              }
 603   1              
 604   1              
 605   1      }
 606          //print the map by the right screen. 
 607          //screen 2 = upper half. 
 608          //sceren 3 = bottom half.
 609          void print_map(int screen)
 610          {
 611   1              short i;
 612   1              if (screen==4 || screen==5)
 613   1              {
C51 COMPILER V9.59.0.0   BATTLESHIPS                                                       06/30/2019 22:25:06 PAGE 11  

 614   2                      
 615   2                              for (i=0;i<16;i++)
 616   2                              {
 617   3                                      LCD_BF();
 618   3                                      LCD_DAT(map[(0+2*(screen/5))][i]);
 619   3                                      LCD_BF();
 620   3                              }
 621   2                              LCD_GOTO(0x40);
 622   2                              for (i=0;i<16;i++)
 623   2                              {
 624   3                                      LCD_BF();
 625   3                                      LCD_DAT(map[1+2*(screen/5)][i]);
 626   3                                      LCD_BF();
 627   3                              }
 628   2              }
 629   1      }
 630          
 631          
 632          void screen_end(char win)
 633          {
 634   1              char* message;
 635   1              if (win=='w')
 636   1              {
 637   2                      message = "WINNER!";
 638   2              }
 639   1              else if(win=='l')
 640   1              {
 641   2                      message = "LOOSER!";
 642   2              }
 643   1              else
 644   1              {
 645   2                      message = "ERROR!";
 646   2              }
 647   1              LCD_CLRS(); // clears the display
 648   1              LCD_BF();// wait untill the LCD is no longer busy
 649   1              LCD_CMD(0x02);// move the cursor home
 650   1              LCD_BF();// wait untill the LCD is no longer busy
 651   1              LCD_MSG(message);
 652   1              LCD_BF();// wait untill the LCD is no longer busy
 653   1              delay(4);//wait 4 seconds.
 654   1              LCD_CLRS();
 655   1              LCD_BF();// wait untill the LCD is no longer busy
 656   1              LCD_MSG("please press");
 657   1              LCD_BF();
 658   1              LCD_GOTO(0x40);
 659   1              LCD_BF();
 660   1              LCD_MSG("reset button!.");
 661   1              LCD_BF();// wait untill the LCD is no longer busy
 662   1              while(1);
 663   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2421    ----
   CONSTANT SIZE    =    137    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     78      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
